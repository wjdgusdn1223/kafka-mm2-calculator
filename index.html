<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka & MirrorMaker2 リソース計算機</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab:hover {
            background: #e9ecef;
        }

        .tab.active:hover {
            background: #5a6fd8;
        }

        .tab-content {
            display: none;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tab-content.active {
            display: block;
        }

        .form-section {
            margin-bottom: 30px;
        }

        .form-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group small {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.9rem;
        }

        .calculate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 20px;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .results {
            margin-top: 30px;
        }

        .result-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .result-section h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .resource-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .resource-table th, .resource-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .resource-table th {
            background-color: #667eea;
            color: white;
            font-weight: 600;
        }

        .resource-table tr:hover {
            background-color: #f1f3f4;
        }

        .explanation {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 4px solid #2196f3;
        }

        .explanation h5 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .explanation ul {
            padding-left: 20px;
        }

        .explanation li {
            margin-bottom: 5px;
        }

        .knowledge-section {
            margin-bottom: 30px;
        }

        .knowledge-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.4rem;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .knowledge-content {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            line-height: 1.7;
        }

        .knowledge-content h4 {
            color: #495057;
            margin: 20px 0 10px 0;
        }

        .knowledge-content ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .knowledge-content li {
            margin-bottom: 8px;
        }

        .formula {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
            font-family: monospace;
            font-size: 0.95rem;
        }

        .warning {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #dc3545;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #17a2b8;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                border-bottom: 1px solid #dee2e6;
            }
            
            .tab:last-child {
                border-bottom: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Kafka & MirrorMaker2 リソース計算機</h1>
            <p>KRaftモード対応 - Kubernetesデプロイメント用のリソース算定ツール</p>
            <div class="warning" style="background: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; margin-top: 15px; border-left: 4px solid #dc3545;">
                <strong>⚠️ 重要な注意事項</strong><br>
                本ツールの計算結果は参考値であり、正確な最終回答ではありません。Kafka と MirrorMaker2 導入時のリソース量を概算するための目安としてご利用ください。実際の環境では必ず負荷テストとモニタリングによる調整が必要です。
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="openTab(event, 'calculator')">リソース計算</button>
            <button class="tab" onclick="openTab(event, 'knowledge')">ベース知識</button>
        </div>

        <div id="calculator" class="tab-content active">
            <form id="calculatorForm">
                <div class="form-section">
                    <h3>基本パラメータ</h3>
                    
                    <div class="form-group">
                        <label for="messagesPerSecond">メッセージ処理量（メッセージ/秒）</label>
                        <input type="number" id="messagesPerSecond" name="messagesPerSecond" value="10000" min="1" required>
                        <small>クラスターに流入する平均またはピークメッセージ数。MirrorMaker2による複製トラフィックは無視して入力してください（自動で計算に含まれます）。</small>
                    </div>

                    <div class="form-group">
                        <label for="avgMessageSize">平均メッセージサイズ（KB）</label>
                        <input type="number" id="avgMessageSize" name="avgMessageSize" value="1" min="0.1" step="0.1" required>
                        <small>各メッセージの平均サイズ。処理量と掛け合わせて秒間データ量を計算します。</small>
                    </div>

                    <div class="form-group">
                        <label for="totalPartitions">総パーティション数</label>
                        <input type="number" id="totalPartitions" name="totalPartitions" value="1000" min="1" required>
                        <small>すべてのトピックのパーティション数の合計。双方向ミラーリングの場合は複製トピックが追加されるため、実際のパーティション数は2倍として計算されます。MirrorMaker2による複製パーティションは無視して入力してください。</small>
                    </div>

                    <div class="form-group">
                        <label for="retentionDays">メッセージ保管期間（日）</label>
                        <input type="number" id="retentionDays" name="retentionDays" value="7" min="1" required>
                        <small>データがクラスターに保存される期間。ストレージ容量計算に使用されます。</small>
                    </div>

                    <div class="form-group">
                        <label for="replicationFactor">レプリケーションファクター</label>
                        <input type="number" id="replicationFactor" name="replicationFactor" value="3" min="1" max="7" required>
                        <small>各トピックの複製本数。通常は3を推奨します。</small>
                    </div>

                    <div class="form-group">
                        <label for="consumerGroups">コンシューマーグループ数</label>
                        <input type="number" id="consumerGroups" name="consumerGroups" value="2" min="1" required>
                        <small>同時に同じデータを購読する独立したコンシューマーグループの数。MirrorMaker2も1つのコンシューマーグループとして計算されます。</small>
                    </div>

                    <div class="form-group">
                        <label for="compressionEnabled">メッセージ圧縮使用</label>
                        <select id="compressionEnabled" name="compressionEnabled" required>
                            <option value="true">あり（snappy、lz4等推奨）</option>
                            <option value="false">なし</option>
                        </select>
                        <small>プロデューサーでのメッセージ圧縮使用。一般的にプロダクション環境では有効にします。CPU使用量が増加しますが、ネットワーク・ストレージ効率が向上します。</small>
                    </div>

                    <div class="form-group">
                        <label for="tlsEnabled">TLS暗号化使用</label>
                        <select id="tlsEnabled" name="tlsEnabled" required>
                            <option value="false">なし（プレーンテキスト通信）</option>
                            <option value="true">あり（SSL/TLS暗号化）</option>
                        </select>
                        <small>クライアント-ブローカー間とブローカー間通信のTLS暗号化。有効にするとブローカーとMM2のCPU使用量が増加します。</small>
                    </div>

                    <details class="form-group">
                        <summary>🔧 高度なハードウェア設定 (OpenShiftクラスター安全上限値)</summary>
                        <div style="margin-top: 15px;">
                            <div class="form-group">
                                <label for="nicBandwidth">ネットワーク帯域幅 (Gbps):</label>
                                <input type="number" id="nicBandwidth" name="nicBandwidth" value="25" min="1" max="100">
                                <small>ブローカーノードのNIC帯域幅。OpenShift標準: 25GbE</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="diskThroughput">ディスク処理量 (MB/s):</label>
                                <input type="number" id="diskThroughput" name="diskThroughput" value="3000" min="500" max="10000">
                                <small>ブローカーノードのストレージ処理量。OpenShift推奨: NVMe 3GB/s</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="cacheMinutes">ページキャッシュ時間 (分):</label>
                                <input type="number" id="cacheMinutes" name="cacheMinutes" value="5" min="1" max="60">
                                <small>コンシューマーが最大何分後までメモリから読むか設定。基本5分</small>
                            </div>
                            
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                ※ ブローカーは別々のノードに配置される前提で計算します。実測後にこれらの値を調整してください。
                            </p>
                        </div>
                    </details>
                </div>

                <div class="form-section">
                    <h3>MirrorMaker2設定</h3>
                    
                    <div class="form-group">
                        <label for="mirroringType">ミラーリングタイプ</label>
                        <select id="mirroringType" name="mirroringType" required>
                            <option value="bidirectional">双方向 (Blue ⇄ Green)</option>
                            <option value="unidirectional">単方向 (Blue → Green)</option>
                        </select>
                        <small>単方向同期を実施している場合は単方向を選択してください。</small>
                    </div>
                </div>

                <button type="submit" class="calculate-btn">リソースを計算する</button>
            </form>

            <div id="results" class="results" style="display: none;"></div>
        </div>

        <div id="knowledge" class="tab-content">
            <div class="knowledge-section">
                <h3>入力パラメータの詳細説明</h3>
                <div class="knowledge-content">
                    <h4>1. メッセージ処理量（メッセージ/秒）</h4>
                    <p>クラスターに流入する平均またはピークメッセージ数を意味します。これにより秒間バイト処理量を計算できます（例：msgs_per_sec × avg_msg_size）。</p>
                    <div class="info">
                        <strong>双方向ミラーリングの自動計算：</strong><br>
                        MirrorMaker2による複製トラフィックは無視して入力してください。双方向ミラーリングの場合、各クラスターには入力したデータとMirrorMaker2による複製データが共存するため、実際の処理量は入力値の2倍として自動計算されます。
                    </div>

                    <h4>2. 平均メッセージサイズ（KB）</h4>
                    <p>各メッセージの平均サイズです。メッセージサイズと処理量を掛けて秒間データ量（例：MB/s）を計算し、ディスクおよびネットワーク容量計算に使用します。</p>
                    <div class="formula">
                        例：平均1KBメッセージを秒間10,000件処理 = 約10MB/sのデータ率
                    </div>

                    <h4>3. 総パーティション数</h4>
                    <p>すべてのトピックのパーティション数の合計です。MirrorMaker2による複製パーティションは無視して入力してください。</p>
                    <div class="warning">
                        <strong>重要：</strong> 双方向ミラーリングの場合、複製トピックが追加されるため実際のパーティション数は2倍として自動計算されます。この値はリーダー+フォロワーレプリカを全て含んだパーティション総計として計算されます。
                    </div>

                    <h4>4. メッセージ保管期間（日）</h4>
                    <p>データがクラスターに保存される期間で、与えられたretention期間中に保存される総データ量を計算するのに必要です。</p>
                    <div class="formula">
                        例：日次データ流入量1TB、保管期間7日 → 最低7TBのストレージ必要（レプリカファクターおよび余裕容量除く）
                    </div>

                    <h4>5. レプリケーションファクター</h4>
                    <p>各トピックの複製本数です（例：3）。レプリケーションファクターがrの場合、1つのメッセージがクラスター内r個のブローカーに保存されるため、保存容量および内部複製トラフィックがr倍増加します。</p>

                    <h4>6. コンシューマーグループ数</h4>
                    <p>同時に同じデータを購読する独立したコンシューマーグループの数です。コンシューマーグループが多いほどブローカーのアウトバウンドトラフィックが増加します。</p>
                    <div class="info">
                        <strong>MirrorMaker2の考慮：</strong><br>
                        MirrorMaker2もソースクラスター側では1つのコンシューマーグループとして動作するため、MM2による負荷を計算に含める必要があります。
                    </div>

                    <h4>7. メッセージ圧縮使用</h4>
                    <p>プロデューサーでメッセージ圧縮（snappy、lz4、gzip、zstd等）を使用するかどうかの設定です。</p>
                    <div class="info">
                        <strong>一般的な運用パターン：</strong><br>
                        プロダクション環境では通常圧縮を有効にします。snappyやlz4は低CPUオーバーヘッドで良好な圧縮率を提供し、ネットワーク帯域とストレージコストを大幅に削減できます。圧縮使用時はブローカーで+4vCPU、MM2で+1vCPU程度の追加リソースが必要ですが、全体的なコスト効率は向上します。
                    </div>

                    <h4>8. TLS暗号化使用</h4>
                    <p>クライアント-ブローカー間通信およびブローカー間通信でSSL/TLS暗号化を使用するかどうかの設定です。</p>
                    <div class="info">
                        <strong>セキュリティとパフォーマンス：</strong><br>
                        TLS暗号化はデータの機密性を保護しますが、暗号化・復号化処理でCPU使用量が大幅に増加します。特にハンドシェイク処理と継続的な暗号化でブローカーとMM2両方のCPU負荷が増加します。TLS使用時はブローカーで+4vCPU、MM2で+1vCPU程度の追加リソースが必要です。
                    </div>
                </div>
            </div>

            <div class="knowledge-section">
                <h3>リソース計算の根拠</h3>
                <div class="knowledge-content">
                    <h4>Kafka コントローラー（KRaftモード）</h4>
                    <ul>
                        <li><strong>Pod数設計理論：</strong>
                            <ul>
                                <li><strong>Raftアルゴリズム基準:</strong> 2n+1の奇数構成で過半数合意を実現</li>
                                <li><strong>可用性計算:</strong> 3台構成では1台障害まで許容（最低稼働2台）</li>
                                <li><strong>プロダクション推奨:</strong> 3台（標準）または5台（高可用性要求時）</li>
                                <li><strong>実際の設定値:</strong> 固定3台（リーダー選出・フェイルオーバー時間最適化）</li>
                            </ul>
                        </li>
                        <li><strong>CPU配分設計：</strong>
                            <ul>
                                <li><strong>役割分析:</strong> メタデータログ管理、ブローカー状態監視、リーダー選出処理</li>
                                <li><strong>負荷特性:</strong> I/O待機が多くCPU集約的ではないが、リアルタイム応答が重要</li>
                                <li><strong>安定性優先:</strong> 4vCPU固定（低負荷でも十分なマージン確保）</li>
                                <li><strong>実測値基準:</strong> Confluent本番環境での推奨構成を採用</li>
                            </ul>
                        </li>
                        <li><strong>メモリ設計詳細：</strong>
                            <ul>
                                <li><strong>JVMヒープ:</strong> 1GB（Kafkaコントローラーは軽量メモリ使用）</li>
                                <li><strong>メタデータキャッシュ:</strong> 約1GB（ブローカー情報・パーティション状態）</li>
                                <li><strong>OS・カーネル:</strong> 約1GB（システムオーバーヘッド）</li>
                                <li><strong>安全余裕:</strong> 約1GB（ピーク時・GCバッファ）</li>
                                <li><strong>合計設計:</strong> 4GB/Pod（実用的かつ安定的な構成）</li>
                            </ul>
                        </li>
                        <li><strong>ストレージ要件根拠：</strong>
                            <ul>
                                <li><strong>データ特性:</strong> メタデータログ（小サイズ・高頻度書込み）</li>
                                <li><strong>性能要求:</strong> 低レイテンシ必須（リーダー選出・フェイルオーバー速度に直結）</li>
                                <li><strong>容量計算:</strong> 64GB SSD（メタデータ成長・ログ保持余裕含む）</li>
                                <li><strong>推奨規格:</strong> NVMe SSD（3.5K IOPS以上、10ms未満レイテンシ）</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Kafka ブローカー</h4>
                    <ul>
                        <li><strong>Pod数：</strong> 
                            <ul>
                                <li><strong>3つの制約を比較：</strong> パーティション制約、ネットワーク制約、ディスクI/O制約の最大値を採用</li>
                                <li><strong>パーティション制約：</strong> 
                                    <ul>
                                        <li>1ブローカー当たり最大4,000パーティション推奨</li>
                                        <li>計算: ceil((総パーティション数 × RF) ÷ 4,000)</li>
                                        <li>根拠: パーティションリーダー選出・メタデータ管理負荷</li>
                                    </ul>
                                </li>
                                <li><strong>ネットワーク制約：</strong>
                                    <ul>
                                        <li>25Gbps NIC基準: 理論値3,125MB/s → 安全率80% = 2,500MB/s</li>
                                        <li>実効処理量: 2,500MB/s ÷ (コンシューマーグループ数 + RF - 1)</li>
                                        <li>例: RF=3, 3グループの場合 → 2,500 ÷ (3+2) = 500MB/s/ブローカー</li>
                                    </ul>
                                </li>
                                <li><strong>ディスクI/O制約：</strong>
                                    <ul>
                                        <li>NVMe SSD基準: 理論値3,000MB/s → 安全率70% = 2,100MB/s</li>
                                        <li>実効処理量: 2,100MB/s ÷ RF（書込み複製負荷）</li>
                                        <li>例: RF=3の場合 → 2,100 ÷ 3 = 700MB/s/ブローカー</li>
                                    </ul>
                                </li>
                                <li><strong>最終決定：</strong> max(3台最小, パーティション制約, ネットワーク制約, ディスク制約)</li>
                            </ul>
                        </li>
                        <li><strong>CPU設計理論：</strong> 
                            <ul>
                                <li><strong>Kafkaワークロード特性:</strong>
                                    <ul>
                                        <li>プロデューサー処理: ネットワークI/O + バッチ書込み + 圧縮処理</li>
                                        <li>コンシューマー処理: ディスクI/O + キャッシュ管理 + ネットワーク送信</li>
                                        <li>内部処理: レプリケーション + パーティション管理 + メタデータ同期</li>
                                        <li>I/O待機時間が多く、マルチコアの並列処理が効果的</li>
                                    </ul>
                                </li>
                                <li><strong>p値（処理能力係数）計算根拠:</strong>
                                    <ul>
                                        <li><strong>ベース値設定:</strong> 20 MB/s per vCPU（标準環境ベンチマーク）</li>
                                        <li><strong>メッセージサイズ影響:</strong>
                                            <ul>
                                                <li>小型(&lt;1KB): ×0.5係数 → 10 MB/s/vCPU（コンテストスイッチングオーバーヘッド）</li>
                                                <li>標準(1-10KB): ×1.0係数 → 20 MB/s/vCPU（最適化されたサイズ）</li>
                                                <li>大型(&gt;10KB): ×1.5係数 → 30 MB/s/vCPU（バッチ処理効率向上）</li>
                                            </ul>
                                        </li>
                                        <li><strong>TLS暗号化影響:</strong> ×0.7係数（SSL/TLSハンドシェイク+暗号化CPUコスト）</li>
                                        <li><strong>圧縮処理影響:</strong> ×0.6係数（gzip/snappy/lz4アルゴリズムCPU使用）</li>
                                        <li><strong>複合影響:</strong> TLS+圧縮使用時は乗算ではなく調整係数適用</li>
                                    </ul>
                                </li>
                                <li><strong>安全率設計:</strong>
                                    <ul>
                                        <li><strong>60%利用率制限:</strong> 平常時の安定性確保</li>
                                        <li><strong>ピーク時対応:</strong> トラフィックスパイク時のバッファ磺保</li>
                                        <li><strong>GC影響軽減:</strong> CPU余裕でJVM GC一時停止対応</li>
                                        <li><strong>運用余裕:</strong> メンテナンス、ローリングアップデート時の安全性</li>
                                    </ul>
                                </li>
                                <li><strong>実装方法:</strong> 処理量 ÷ (p値 × 0.6) = 必要vCPU数（切り上げ）</li>
                            </ul>
                        </li>
                        <li><strong>メモリアーキテクチャ設計：</strong> 
                            <ul>
                                <li><strong>JVMヒープ最適化:</strong>
                                    <ul>
                                        <li><strong>固定6GB推奨根拠:</strong> Kafkaのメモリプロファイル分析結果</li>
                                        <li><strong>GC最適化:</strong> G1GCでのパフォーマンス・レイテンシバランス</li>
                                        <li><strong>大容量ヒープの問題点:</strong> 8GB以上ではGC一時停止時間が延長</li>
                                        <li><strong>Kafka設計思想:</strong> Off-heap使用でJVMヒープ依存度を低減</li>
                                    </ul>
                                </li>
                                <li><strong>直接バッファ（Off-heap）詳細:</strong>
                                    <ul>
                                        <li><strong>TLS暗号化バッファ:</strong> JVMヒープ × 10% = 0.6GB</li>
                                        <li><strong>圧縮処理バッファ:</strong> JVMヒープ × 10% = 0.6GB</li>
                                        <li><strong>両方使用時:</strong> 最大1.2GB（重複しない独立バッファ）</li>
                                        <li><strong>用途:</strong> ネットワークI/O・コーデック処理・TLSハンドシェイク</li>
                                    </ul>
                                </li>
                                <li><strong>ページキャッシュ設計理論:</strong>
                                    <ul>
                                        <li><strong>計算式:</strong> (ブローカー当たり処理量MB/s × 300秒) ÷ 1024 = キャッシュサイズGB</li>
                                        <li><strong>5分キャッシュ根拠:</strong> コンシューマーの遅延読み取りパターン分析</li>
                                        <li><strong>効果:</strong> 最近書き込みデータの高速読み取り（Zero-copy最適化）</li>
                                        <li><strong>OSファイルシステムキャッシュ:</strong> Linuxカーネルの自動メモリ管理活用</li>
                                    </ul>
                                </li>
                                <li><strong>OS・カーネル予約:</strong>
                                    <ul>
                                        <li><strong>予約率:</strong> 上記合計 × 10%（カーネル・システムバッファ）</li>
                                        <li><strong>用途内訳:</strong> ネットワークスタック、ファイルシステムバッファ、カーネル構造体</li>
                                    </ul>
                                </li>
                                <li><strong>メモリ構成実例:</strong>
                                    <ul>
                                        <li><strong>低負荷環境:</strong> 16GB = JVM6GB + 直接0.6GB + ページキャッシュ7.4GB + OS2GB</li>
                                        <li><strong>中負荷環境:</strong> 32GB = JVM6GB + 直接1.2GB + ページキャッシュ22.8GB + OS2GB</li>
                                        <li><strong>高負荷環境:</strong> 64GB = JVM6GB + 直接1.2GB + ページキャッシュ54.8GB + OS2GB</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><strong>ストレージ設計理論：</strong> 
                            <ul>
                                <li><strong>データ成長予測計算:</strong>
                                    <ul>
                                        <li><strong>日次データ量:</strong> 秒間データ量 × 86,400秒 ÷ 1024³</li>
                                        <li><strong>保持データ総量:</strong> 日次データ量 × 保管日数</li>
                                        <li><strong>レプリケーション影響:</strong> 保持データ総量 × RF（複製保存）</li>
                                        <li><strong>ブローカー分散:</strong> 総データ量 ÷ ブローカー数</li>
                                    </ul>
                                </li>
                                <li><strong>85%使用率制限根拠:</strong>
                                    <ul>
                                        <li><strong>ファイルシステム制限:</strong> ext4/xfsでフラグメンテーション防止</li>
                                        <li><strong>コンパクション余裕:</strong> ログセグメント統合処理用領域確保</li>
                                        <li><strong>運用余裕:</strong> ログローテーション、スナップショット、メンテナンス作業</li>
                                        <li><strong>性能保持:</strong> ディスク使用率90%超過時の書込み性能低下回避</li>
                                    </ul>
                                </li>
                                <li><strong>ストレージタイプ推奨:</strong>
                                    <ul>
                                        <li><strong>NVMe SSD:</strong> 高スループット・低レイテンシ環境用</li>
                                        <li><strong>SATA SSD:</strong> コスト重視・中程度負荷環境用</li>
                                        <li><strong>HDD:</strong> コールドストレージ・アーカイブ用途のみ</li>
                                    </ul>
                                </li>
                                <li><strong>計算例:</strong> 日次100GB × 30日 × RF3 = 9TB → 9TB ÷ 0.85 = 10.6TB/ブローカー（安全率適用後）</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>MirrorMaker2（クロスデータセンター複製）</h4>
                    <ul>
                        <li><strong>Pod数：</strong> 
                            <ul>
                                <li>Kafka Connectフレームワーク上で動作、高可用性のため最低2つ以上のワーカーノード</li>
                                <li>双方向同期（Active-Active）では各方向に別個のコネクターが必要</li>
                            </ul>
                        </li>
                        <li><strong>tasks.max：</strong> 
                            <ul>
                                <li>理想設定：min(複製元パーティション総数, 利用可能CPUコア数)</li>
                                <li>1タスクにつき1コア程度を割り当てる想定で計画</li>
                                <li>例：ソース10パーティション、8CPUコアの場合 → tasks.max = 8</li>
                            </ul>
                        </li>
                        <li><strong>CPU設計（処理量基準）：</strong> 
                            <ul>
                                <li><strong>p値計算理論:</strong>
                                    <ul>
                                        <li>基本処理能力: 15 MB/s per vCPU（同一DC内標準）</li>
                                        <li>TLS暗号化影響: ×0.67係数（暗号化オーバーヘッド約30%）</li>
                                        <li>圧縮処理影響: ×0.67係数（CPU使用量増加約30%）</li>
                                        <li>両方使用時: ×0.4係数（複合的な性能低下）</li>
                                        <li>実測値基準: Instaclustr・Aiven運用データより導出</li>
                                    </ul>
                                </li>
                                <li><strong>必要CPU算出ステップ:</strong>
                                    <ul>
                                        <li>基本必要量: 処理量(MB/s) ÷ p値(MB/s/vCPU)</li>
                                        <li>安全率適用: 基本必要量 ÷ 0.6（60%利用率制限）</li>
                                        <li>切り上げ処理: ceil()で整数vCPUに調整</li>
                                        <li>Pod分配: 総CPU ÷ ワーカー数 = Pod当たりCPU</li>
                                        <li>最小保証: max(2vCPU, 計算値) でPod当たり最小2vCPU確保</li>
                                    </ul>
                                </li>
                                <li><strong>設計思想変更:</strong> 固定加算方式から実処理量比例方式へ移行（より正確な算定）</li>
                            </ul>
                        </li>
                        <li><strong>メモリ設計（オープンソース実運用基準）：</strong> 
                            <ul>
                                <li><strong>JVMヒープ詳細計算:</strong>
                                    <ul>
                                        <li><strong>最小保証:</strong> 2GB（MM2基本動作に必要な最小ヒープ）</li>
                                        <li><strong>タスク比例:</strong> 0.5GB × tasks.max（並列処理バッファ確保）</li>
                                        <li><strong>選択ロジック:</strong> max(2GB, タスク数基準値)で最適値決定</li>
                                        <li><strong>実例計算:</strong> tasks.max=6 → max(2GB, 3GB) = 3GB</li>
                                        <li><strong>根拠:</strong> Kafka Connect tasks個あたり平均0.5GBバッファ使用実測</li>
                                    </ul>
                                </li>
                                <li><strong>直接バッファ（Off-heap）:</strong>
                                    <ul>
                                        <li><strong>割合設定:</strong> JVMヒープ × 20%（Netty I/Oバッファ）</li>
                                        <li><strong>用途詳細:</strong> TLS暗号化バッファ + ネットワークI/Oバッファ</li>
                                        <li><strong>実測根拠:</strong> MM2でのNetty使用量分析結果</li>
                                    </ul>
                                </li>
                                <li><strong>OS・カーネル予約:</strong>
                                    <ul>
                                        <li><strong>固定値:</strong> 1GB（システム・カーネルバッファ）</li>
                                        <li><strong>内訳:</strong> プロセス管理0.3GB + ネットワークスタック0.4GB + 其他0.3GB</li>
                                    </ul>
                                </li>
                                <li><strong>安全余裕設計:</strong>
                                    <ul>
                                        <li><strong>余裕率:</strong> 基本合計 × 10%（GC・ピーク時対応）</li>
                                        <li><strong>目的:</strong> Old Generation GC時の一時的メモリ増加対応</li>
                                    </ul>
                                </li>
                                <li><strong>最終メモリ決定:</strong> ceil((ヒープ + 直接バッファ + OS) × 1.1)</li>
                                <li><strong>AWS MCU比較:</strong> MSK Connect 4GB/vCPU対比約50%効率化（但し実用性確保）</li>
                                <li><strong>具体例:</strong> tasks.max=4 → ヒープ2GB + 直接0.4GB + OS1GB + 余裕0.34GB = 4GB/Pod</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="knowledge-section">
                <h3>計算式の詳細</h3>
                <div class="knowledge-content">
                    <h4>基本データ量の計算</h4>
                    <div class="formula">
                        秒間データ量(bytes) = メッセージ/秒 × 平均メッセージサイズ(KB) × 1024
                        日次データ量(GB) = 秒間データ量 × 86400秒 ÷ (1024³)
                        
                        ※ 双方向ミラーリングの場合は入力値を2倍にして計算
                    </div>

                    <h4>Kafkaコントローラー（KRaft）計算式</h4>
                    <div class="formula">
                        <strong>📊 Pod数:</strong>
                        <ul>
                            <li>固定値: <strong>3台</strong></li>
                            <li>根拠: 過半数合意のため奇数必須（2n+1構成）</li>
                            <li>可用性: 1台障害まで許容</li>
                        </ul>

                        <strong>💾 CPU:</strong>
                        <ul>
                            <li>固定値: <strong>4 vCPU/pod</strong></li>
                            <li>根拠: Confluent公式推奨値</li>
                            <li>用途: メタデータ管理・クラスター状態管理</li>
                        </ul>

                        <strong>🧠 メモリ:</strong>
                        <ul>
                            <li>固定値: <strong>4 GB/pod</strong></li>
                            <li>内訳: JVMヒープ1GB + OS・バッファ3GB</li>
                            <li>特徴: ブローカーより軽量（データ保存なし）</li>
                        </ul>

                        <strong>💽 ストレージ:</strong>
                        <ul>
                            <li>固定値: <strong>64 GB SSD/pod</strong></li>
                            <li>用途: メタデータログ専用</li>
                            <li>要件: 高速アクセス必須（NVMe推奨）</li>
                        </ul>
                    </div>

                    <h4>Kafkaブローカー計算式</h4>
                    <div class="formula">
                        <strong>📊 Pod数計算:</strong>
                        <ul>
                            <li><strong>Step1:</strong> 3つの制約別必要台数を計算</li>
                            <li>パーティション制約: ceil((総パーティション数 × RF) ÷ 4,000)</li>
                            <li>ネットワーク制約: ceil(総処理量 ÷ NIC安全容量)</li>
                            <li>ディスク制約: ceil(総処理量 ÷ ディスク安全容量)</li>
                            <li><strong>最終決定:</strong> max(3, パーティション制約, ネットワーク制約, ディスク制約)</li>
                            <li>安全容量 = 理論容量 × 安全率 ÷ (コンシューマーグループ数+RF-1)</li>
                        </ul>

                        <strong>💾 CPU計算:</strong>
                        <ul>
                            <li><strong>p値計算:</strong> 20 MB/s (基本) × サイズ係数 × TLS係数 × 圧縮係数</li>
                            <li>メッセージサイズ係数: ＜1KB→0.5, 1-10KB→1.0, ＞10KB→1.5</li>
                            <li>TLS係数: 使用時 0.7 (30%オーバーヘッド)</li>
                            <li>圧縮係数: 使用時 0.6 (40%オーバーヘッド)</li>
                            <li><strong>CPU計算:</strong> ceil((ブローカー当たり処理量 ÷ p値) ÷ 0.6安全率)</li>
                            <li><strong>最終値:</strong> max(4vCPU, 計算値)</li>
                        </ul>

                        <strong>🧠 メモリ計算:</strong>
                        <ul>
                            <li><strong>JVMヒープ:</strong> 6GB 固定 (Kafka推奨)</li>
                            <li><strong>直接バッファ:</strong> 
                                <ul>
                                    <li>TLS使用時: ヒープ × 10% = 0.6GB</li>
                                    <li>圧縮使用時: ヒープ × 10% = 0.6GB</li>
                                </ul>
                            </li>
                            <li><strong>ページキャッシュ:</strong> (ブローカー当たり処理量MB/s × キャッシュ分数 × 60秒) ÷ 1024</li>
                            <li><strong>OS余裕:</strong> 上記合計 × 10%</li>
                            <li><strong>最終メモリ:</strong> 計算値 (32-64GBは高負荷環境推奨)</li>
                        </ul>

                        <strong>💽 ストレージ計算:</strong>
                        <ul>
                            <li><strong>日次データ:</strong> (秒間バイト数 × 86,400秒) ÷ 1024³</li>
                            <li><strong>保管期間データ:</strong> 日次データ × 保管日数</li>
                            <li><strong>総必要容量:</strong> 保管期間データ × RF</li>
                            <li><strong>ブローカー当たり容量:</strong> 総必要容量 ÷ ブローカー数</li>
                            <li><strong>PVC容量:</strong> ブローカー当たり容量 ÷ 0.85 (85%使用率制限)</li>
                        </ul>
                    </div>

                    <h4>MirrorMaker2計算式</h4>
                    <div class="formula">
                        <strong>📊 インスタンス・ワーカー構成:</strong>
                        <ul>
                            <li><strong>単方向:</strong> 1インスタンス × 2ワーカー = 2Pod</li>
                            <li><strong>双方向:</strong> 2インスタンス × 2ワーカー = 4Pod (方向あたり2Pod)</li>
                            <li><strong>高可用性:</strong> 各インスタンスに2ワーカー配置推奨</li>
                            <li><strong>独立性:</strong> 双方向でも各方向は独立動作</li>
                        </ul>

                        <strong>💾 CPU計算:</strong>
                        <ul>
                            <li><strong>処理量計算:</strong> (入力メッセージ/秒 × 平均メッセージサイズKB) ÷ 1024</li>
                            <li><strong>MM2 p値 (同一DC内基準):</strong>
                                <ul>
                                    <li>標準: 15 MB/s/vCPU</li>
                                    <li>TLS使用: 10 MB/s/vCPU</li>
                                    <li>圧縮使用: 10 MB/s/vCPU</li>
                                    <li>TLS+圧縮: 6 MB/s/vCPU</li>
                                </ul>
                            </li>
                            <li><strong>必要総CPU:</strong> ceil(処理量 ÷ (p値 × 0.6安全率))</li>
                            <li><strong>Pod当たりCPU:</strong> max(2vCPU, ceil(必要総CPU ÷ ワーカー数))</li>
                            <li><strong>実際の総CPU:</strong> Pod当たりCPU × ワーカー数</li>
                        </ul>

                        <strong>⚡ tasks.max計算:</strong>
                        <ul>
                            <li><strong>基本原則:</strong> CPU1コア当たり1タスクが理想並列度</li>
                            <li><strong>計算式:</strong> min(複製対象パーティション数, MM2総CPU数)</li>
                            <li><strong>制限要因:</strong> パーティション数またはCPU数の小さい方</li>
                        </ul>

                        <strong>🧠 メモリ計算 (実運用基準):</strong>
                        <ul>
                            <li><strong>JVMヒープ:</strong> max(2GB, 0.5GB × tasks.max)</li>
                            <li><strong>直接バッファ:</strong> ヒープ × 20% (Netty + TLS)</li>
                            <li><strong>OS・カーネル:</strong> 1GB (固定)</li>
                            <li><strong>安全余裕:</strong> 上記合計 × 10%</li>
                            <li><strong>最終メモリ:</strong> ceil((ヒープ + 直接バッファ + OS) × 1.1)</li>
                            <li><strong>特徴:</strong> AWS MSK Connect MCU (4GB/vCPU)より節約的</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="knowledge-section">
                <h3>参考文献・出典</h3>
                <div class="knowledge-content">
                    <h4>公式ドキュメント</h4>
                    <ul>
                        <li><a href="https://docs.confluent.io/platform/current/kafka-metadata/config-kraft.html" target="_blank">Configure and Monitor KRaft | Confluent Documentation</a></li>
                        <li><a href="https://docs.confluent.io/platform/current/installation/system-requirements.html" target="_blank">Confluent Platform System Requirements | Confluent Documentation</a></li>
                        <li><a href="https://docs.confluent.io/platform/current/kafka/deployment.html" target="_blank">Running Kafka in Production with Confluent Platform</a></li>
                        <li><a href="https://docs.aws.amazon.com/msk/latest/developerguide/bestpractices.html" target="_blank">Best practices for Standard brokers - Amazon Managed Streaming for Apache Kafka</a></li>
                        <li><a href="https://docs.aws.amazon.com/msk/latest/developerguide/msk-encryption.html" target="_blank">Amazon MSK encryption - Amazon Managed Streaming for Apache Kafka</a></li>
                        <li><a href="https://docs.aws.amazon.com/msk/latest/developerguide/msk-connect-capacity.html" target="_blank">Understand connector capacity - Amazon Managed Streaming for Apache Kafka</a></li>
                        <li><a href="https://cloud.google.com/managed-service-for-apache-kafka/pricing" target="_blank">Managed Service for Apache Kafka pricing | Google Cloud</a></li>
                        <li><a href="https://docs.cloudera.com/cdp-private-cloud-base/7.3.1/kafka-performance-tuning/topics/kafka-tune-sizing-calc.html" target="_blank">Sizing estimation based on network and disk message throughput | Cloudera</a></li>
                    </ul>

                    <h4>パフォーマンス・最適化</h4>
                    <ul>
                        <li><a href="https://aws.amazon.com/blogs/big-data/best-practices-for-right-sizing-your-apache-kafka-clusters-to-optimize-performance-and-cost/" target="_blank">Best practices for right-sizing your Apache Kafka clusters to optimize performance and cost | AWS Big Data Blog</a></li>
                        <li><a href="https://www.intel.com/content/www/us/en/developer/articles/guide/kafka-optimization-and-benchmarking-guide.html" target="_blank">Apache Kafka Optimization & Benchmarking Guide - Intel</a></li>
                        <li><a href="https://repost.aws/knowledge-center/msk-broker-high-cpu-usage" target="_blank">Troubleshoot high CPU usage on MSK brokers - AWS re:Post</a></li>
                        <li><a href="https://www.confluent.io/blog/apache-kafka-supports-200k-partitions-per-cluster/" target="_blank">Apache Kafka Supports 200K Partitions Per Cluster | Confluent</a></li>
                        <li><a href="https://www.instaclustr.com/blog/how-to-size-apache-kafka-clusters-for-tiered-storage-part-3/" target="_blank">How to size Apache Kafka® clusters for Tiered Storage: Part 3 - Instaclustr</a></li>
                        <li><a href="https://medium.com/@akash.d.goel/kafka-hardware-requirements-9328886fe88f" target="_blank">Kafka Hardware Requirements - Medium</a></li>
                        <li><a href="https://github.com/AutoMQ/automq/wiki/Kafka-Design%3A-Page-Cache-%26-Performance" target="_blank">Kafka Design: Page Cache & Performance - GitHub</a></li>
                    </ul>

                    <h4>圧縮・暗号化・セキュリティ</h4>
                    <ul>
                        <li><a href="https://www.confluent.io/blog/apache-kafka-message-compression/" target="_blank">Apache Kafka Message Compression - Confluent</a></li>
                        <li><a href="https://blog.mimacom.com/apache-kafka-with-ssltls-performance/" target="_blank">Performance considerations when using Apache Kafka with SSL/TLS</a></li>
                        <li><a href="https://blog.cloudflare.com/squeezing-the-firehose/" target="_blank">Squeezing the firehose: getting the most from Kafka compression</a></li>
                    </ul>

                    <h4>ハードウェア・インフラストラクチャ</h4>
                    <ul>
                        <li><a href="https://stackoverflow.com/questions/53858139/what-is-the-recommended-ram-size-for-kafka-brokers-when-we-set-up-the-clauster" target="_blank">What is the Recommended RAM size for kafka brokers when we set up the cluster? - Stack Overflow</a></li>
                        <li><a href="https://access.redhat.com/articles/7110061" target="_blank">Recommended Disk and IOPS Settings for Apache Kafka Brokers on OpenShift</a></li>
                        <li><a href="https://docs.netapp.com/us-en/netapp-solutions/containers/rh-os-n_openshift_BM.html" target="_blank">OpenShift on Bare Metal - Product Documentation - NetApp</a></li>
                        <li><a href="https://docs.redhat.com/en/documentation/openshift_container_platform/3.11/html/scaling_and_performance_guide/scaling-performance-network-optimization" target="_blank">Network Optimization | OpenShift Container Platform</a></li>
                        <li><a href="https://portworx.com/wp-content/uploads/2020/04/experts-guide-kafka-kubernetes.pdf" target="_blank">The Expert's Guide to Running Apache Kafka on Kubernetes [PDF]</a></li>
                        <li><a href="https://www.purestorage.com/content/dam/pdf/en/reference-architectures/ra-portworx-red-hat-openshift-bare-metal.pdf" target="_blank">Portworx on Red Hat OpenShift Bare Metal [PDF] - Pure Storage</a></li>
                    </ul>

                    <h4>MirrorMaker2・Kafka Connect</h4>
                    <ul>
                        <li><a href="https://aiven.io/docs/products/kafka/kafka-mirrormaker/concepts/disaster-recovery/active-active-setup" target="_blank">MirrorMaker 2 active-active setup | Aiven docs</a></li>
                        <li><a href="https://aiven.io/docs/products/kafka/kafka-mirrormaker/reference/advanced-params" target="_blank">Advanced parameters for Aiven for Apache Kafka® MirrorMaker 2 | Aiven docs</a></li>
                        <li><a href="https://www.instaclustr.com/blog/apache-kafka-mirrormaker-2-practice/" target="_blank">Apache Kafka MirrorMaker 2 (MM2) Part 3: Practice</a></li>
                        <li><a href="https://cloud.google.com/managed-service-for-apache-kafka/docs/connect-cluster/create-mirrormaker-connector" target="_blank">Create a MirrorMaker 2.0 connector | Google Cloud</a></li>
                        <li><a href="https://www.redpanda.com/guides/kafka-alternatives-kafka-mirrormaker" target="_blank">Kafka MirrorMaker—Tutorial, best practices and alternatives</a></li>
                        <li><a href="https://stackoverflow.com/questions/67437651/ideal-value-for-kafka-connect-tasks-max-relative-to-number-of-cpu-cores" target="_blank">Ideal value for Kafka Connect tasks.max relative to number of CPU cores? - Stack Overflow</a></li>
                        <li><a href="https://ibm-cloud-architecture.github.io/refarch-eda/technology/kafka-mirrormaker/" target="_blank">Kafka Mirror Maker 2 - IBM Automation - Event-driven Solution</a></li>
                        <li><a href="https://www.automq.com/blog/kafka-mirrormaker-2-usages-best-practices" target="_blank">Kafka MirrorMaker 2 (MM2): Usages and Best Practices</a></li>
                        <li><a href="https://klarrio.medium.com/mirroring-high-throughput-topics-with-kafka-mirrormaker-2-3a7abe158884" target="_blank">Mirroring High-Throughput Topics with Kafka MirrorMaker 2 | by Klarrio</a></li>
                        <li><a href="https://stackoverflow.com/questions/50621962/how-to-set-kafka-connect-connector-and-tasks-jvm-heap-size" target="_blank">How to set kafka-connect connector and task's JVM heap size? - Stack Overflow</a></li>
                        <li><a href="https://risingwave.com/blog/complete-guide-to-kafka-mirrormaker/" target="_blank">Complete Guide to Kafka MirrorMaker - RisingWave</a></li>
                        <li><a href="https://forum.confluent.io/t/kafka-connect-becomes-unhealthy-due-to-oom/2676" target="_blank">Kafka Connect Becomes Unhealthy Due to OOM - Confluent Forum</a></li>
                    </ul>

                    <div class="info">
                        <strong>注意事項：</strong><br>
                        本計算ツールは上記の信頼できるソースに基づいて作成されていますが、実際の環境では必ず負荷テストとモニタリングによる調整を行ってください。リソース要件は具体的なワークロードと環境に大きく依存します。
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function openTab(evt, tabName) {
            var i, tabcontent, tabs;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].classList.remove("active");
            }
            tabs = document.getElementsByClassName("tab");
            for (i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove("active");
            }
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
        }

        document.getElementById('calculatorForm').addEventListener('submit', function(e) {
            e.preventDefault();
            calculateResources();
        });

        function calculateResources() {
            // 入力値を取得
            const messagesPerSecond = parseInt(document.getElementById('messagesPerSecond').value);
            const avgMessageSize = parseFloat(document.getElementById('avgMessageSize').value);
            const totalPartitions = parseInt(document.getElementById('totalPartitions').value);
            const retentionDays = parseInt(document.getElementById('retentionDays').value);
            const replicationFactor = parseInt(document.getElementById('replicationFactor').value);
            const consumerGroups = parseInt(document.getElementById('consumerGroups').value);
            const mirroringType = document.getElementById('mirroringType').value;
            const compressionEnabled = document.getElementById('compressionEnabled').value === 'true';
            const tlsEnabled = document.getElementById('tlsEnabled').value === 'true';

            // 双方向ミラーリングの場合の調整
            const actualMessagesPerSecond = mirroringType === 'bidirectional' ? messagesPerSecond * 2 : messagesPerSecond;
            const actualTotalPartitions = mirroringType === 'bidirectional' ? totalPartitions * 2 : totalPartitions;
            const actualConsumerGroups = consumerGroups + 1; // MM2を1つのコンシューマーグループとして追加

            // 基本計算
            const bytesPerSecond = actualMessagesPerSecond * avgMessageSize * 1024; // KB to bytes
            const dailyDataGB = (bytesPerSecond * 86400) / (1024 * 1024 * 1024); // GB/day
            const totalStorageGB = dailyDataGB * retentionDays * replicationFactor;

            // コントローラー計算
            const controllerPods = 3; // 推奨値
            const controllerCPU = 4; // vCPU per pod
            const controllerMemory = 4; // GB per pod
            const controllerStorage = 64; // GB per pod

            // ブローカー計算（統合リソース制約ベース）
            
            // 1. p値計算（vCPU当たり処理能力）
            let pValue = 20; // ベース値：20 MB/s per vCPU
            if (avgMessageSize < 1) pValue *= 0.5;      // 小型メッセージ（<1KB）
            else if (avgMessageSize > 10) pValue *= 1.5; // 大型メッセージ（>10KB）
            if (tlsEnabled) pValue *= 0.7;              // TLS暗号化オーバーヘッド
            if (compressionEnabled) pValue *= 0.6;       // 圧縮オーバーヘッド
            
            // 2. 全体処理量
            const tCluster = bytesPerSecond / 1024 / 1024; // MB/s
            
            // 3. ハードウェア安全上限値設定
            const nicBandwidthGbps = parseInt(document.getElementById('nicBandwidth').value) || 25;
            const diskThroughputMBps = parseInt(document.getElementById('diskThroughput').value) || 3000;
            
            // 4. 各制約別必要ブローカー数
            const brokersByPartitions = Math.ceil((actualTotalPartitions * replicationFactor) / 4000);
            
            // ブローカー当たり安全処理容量計算（1ブローカー=1ノード前提）
            const capNIC_perBroker = (nicBandwidthGbps * 125 * 0.8) / (actualConsumerGroups + replicationFactor - 1);
            const capDisk_perBroker = (diskThroughputMBps * 0.7) / replicationFactor;
            
            const brokersByNIC = Math.ceil(tCluster / capNIC_perBroker);
            const brokersByDisk = Math.ceil(tCluster / capDisk_perBroker);
            
            // 5. 最終ブローカー数（最も制限的な条件 + 最小3台）
            const brokerPods = Math.max(3, Math.max(brokersByPartitions, brokersByNIC, brokersByDisk));
            
            // 6. ブローカー当たり実際CPU計算
            const tBroker = tCluster / brokerPods;
            let brokerCPU = Math.max(4, Math.ceil(tBroker / (pValue * 0.6))); // 最小4vCPU
            
            // 7. 主要ボトルネック識別
            const bottleneckSource = 
                brokersByPartitions >= Math.max(brokersByNIC, brokersByDisk) ? 'partitions' :
                brokersByNIC >= brokersByDisk ? 'network' : 'disk';

            // ブローカーメモリ計算（改善された方式）
            const cacheMinutes = parseInt(document.getElementById('cacheMinutes').value) || 5;
            
            // 1. JVMヒープ: 6GB（固定）
            const jvmHeap = 6;
            
            // 2. 直接バッファオーバーヘッド（TLS/圧縮各10%）
            let directBufferOverhead = 0;
            if (tlsEnabled) directBufferOverhead += jvmHeap * 0.1; // +0.6GB
            if (compressionEnabled) directBufferOverhead += jvmHeap * 0.1; // +0.6GB
            
            // 3. ページキャッシュ（設定分数 × ブローカー当たり書込量）
            const requiredPageCache = Math.max(2, (tBroker * cacheMinutes * 60) / 1024); // GB
            
            // 4. OS余裕（10%追加）
            const baseMemory = jvmHeap + directBufferOverhead + requiredPageCache;
            const calculatedMemory = Math.ceil(baseMemory * 1.1);
            
            // 5. 計算結果をそのまま使用
            const brokerMemory = calculatedMemory;
            const brokerStoragePerPod = Math.ceil((totalStorageGB / brokerPods) / 0.85); // 85%利用率考慮

            // MM2計算（双方向でも単方向基準でリソース計算）
            const mm2Instances = mirroringType === 'bidirectional' ? 2 : 1;
            const mm2WorkersPerInstance = 2; // 推奨値
            // 注意：双方向の場合、2つの独立した単方向同期として動作
            // リソース計算は1つの方向（単方向）基準で行う
            const mm2TotalWorkersPerDirection = mm2WorkersPerInstance; // 単方向基準
            
            // MM2 p値計算（同一DC内配置基準）
            let mm2PValue = 15; // 基本値：15 MB/s per vCPU（TLS❌、圧縮❌）
            if (tlsEnabled && compressionEnabled) {
                mm2PValue = 6; // TLS + 圧縮：5-8 MB/s（保守的に6を採用）
            } else if (tlsEnabled) {
                mm2PValue = 10; // TLSのみ：10 MB/s per vCPU
            } else if (compressionEnabled) {
                mm2PValue = 10; // 圧縮のみ：10 MB/s per vCPU（TLSと同様のオーバーヘッド）
            }
            
            // MM2が処理すべき実際の処理量（入力値、複製トラフィックは除外）
            const mm2ProcessingLoad = (messagesPerSecond * avgMessageSize) / 1024; // MB/s
            
            // MM2必要総CPU計算（単方向基準、60%安全率適用）
            const mm2RequiredTotalCPU = Math.ceil(mm2ProcessingLoad / (mm2PValue * 0.6));
            
            // ワーカー当たりCPU計算（Pod当たりCPU設定値）
            const mm2CPUPerWorkerCalculated = Math.ceil(mm2RequiredTotalCPU / mm2TotalWorkersPerDirection);
            const mm2CPUPerWorker = Math.max(2, mm2CPUPerWorkerCalculated); // Pod当たり最小2vCPU
            
            // 実際の総CPU（ワーカー当たりCPU × ワーカー数）
            const mm2TotalCPU = mm2CPUPerWorker * mm2TotalWorkersPerDirection;
            
            
            // tasks.max計算（パーティション数と総CPU数の小さい方）
            const tasksMax = Math.min(totalPartitions, mm2TotalCPU);
            
            // MM2メモリ計算（実運用基準、オープンソースMM2直接運用）
            // heap = max(2GB, 0.5GB × tasks.max)
            const mm2HeapSize = Math.max(2, 0.5 * tasksMax);
            // directBuffer = heap × 20%
            const mm2DirectBuffer = mm2HeapSize * 0.2;
            // OS overhead = 1GB
            const mm2OSOverhead = 1;
            // 10%余裕
            const mm2BaseMemory = mm2HeapSize + mm2DirectBuffer + mm2OSOverhead;
            const mm2Memory = Math.ceil(mm2BaseMemory * 1.1); // ワーカー当たりメモリ

            // 結果表示
            displayResults({
                controller: {
                    pods: controllerPods,
                    cpu: controllerCPU,
                    memory: controllerMemory,
                    storage: controllerStorage
                },
                broker: {
                    pods: brokerPods,
                    cpu: brokerCPU,
                    memory: brokerMemory,
                    storage: brokerStoragePerPod,
                    totalStorage: Math.ceil(totalStorageGB / 0.85)
                },
                mm2: {
                    instances: mm2Instances,
                    workersPerInstance: mm2WorkersPerInstance,
                    totalWorkersPerDirection: mm2TotalWorkersPerDirection,
                    cpuPerWorker: mm2CPUPerWorker,
                    totalCPU: mm2TotalCPU,
                    memory: mm2Memory,
                    tasksMax: tasksMax
                },
                calculations: {
                    actualMessagesPerSecond,
                    actualTotalPartitions,
                    actualConsumerGroups,
                    bytesPerSecond,
                    dailyDataGB,
                    totalStorageGB,
                    pValue,
                    tCluster,
                    tBroker,
                    brokersByPartitions,
                    brokersByNIC,
                    brokersByDisk,
                    bottleneckSource,
                    capNIC_perBroker,
                    capDisk_perBroker,
                    nicBandwidthGbps,
                    diskThroughputMBps,
                    cacheMinutes,
                    jvmHeap,
                    directBufferOverhead,
                    requiredPageCache,
                    baseMemory,
                    calculatedMemory,
                    mirroringType,
                    compressionEnabled,
                    tlsEnabled,
                    mm2PValue,
                    mm2ProcessingLoad,
                    mm2RequiredTotalCPU,
                    mm2CPUPerWorkerCalculated,
                    mm2HeapSize,
                    mm2DirectBuffer,
                    mm2OSOverhead,
                    mm2BaseMemory
                }
            });
        }

        function displayResults(results) {
            const resultsDiv = document.getElementById('results');
            
            resultsDiv.innerHTML = `
                <div class="result-section">
                    <h4>🎛️ Kafka コントローラー</h4>
                    <table class="resource-table">
                        <tr><th>リソース</th><th>値</th><th>単位</th></tr>
                        <tr><td>Pod数</td><td>${results.controller.pods}</td><td>個</td></tr>
                        <tr><td>CPU (Request/Limit)</td><td>${results.controller.cpu}</td><td>vCPU/pod</td></tr>
                        <tr><td>メモリ (Request/Limit)</td><td>${results.controller.memory}</td><td>GB/pod</td></tr>
                        <tr><td>ストレージ (PVC)</td><td>${results.controller.storage}</td><td>GB/pod</td></tr>
                    </table>
                    <div class="explanation">
                        <h5>📋 計算根拠</h5>
                        <ul>
                            <li>KRaftモードでは高可用性のために奇数個（通常3個）のコントローラーが必要</li>
                            <li>Confluent推奨仕様：コントローラー当たり4vCPU、4GBメモリ、64GB SSD</li>
                            <li>メタデータログの保存と管理が主な役割のため、比較的軽量な構成</li>
                        </ul>
                    </div>
                </div>

                <div class="result-section">
                    <h4>🏪 Kafka ブローカー</h4>
                    <table class="resource-table">
                        <tr><th>リソース</th><th>値</th><th>単位</th></tr>
                        <tr><td>Pod数</td><td>${results.broker.pods}</td><td>個</td></tr>
                        <tr><td>CPU (Request)</td><td>${results.broker.cpu}</td><td>vCPU/pod</td></tr>
                        <tr><td>CPU (Limit)</td><td>${Math.ceil(results.broker.cpu * 1.5)}</td><td>vCPU/pod</td></tr>
                        <tr><td>メモリ (Request)</td><td>${results.broker.memory}</td><td>GB/pod</td></tr>
                        <tr><td>メモリ (Limit)</td><td>${Math.ceil(results.broker.memory * 1.2)}</td><td>GB/pod</td></tr>
                        <tr><td>ストレージ (PVC)</td><td>${results.broker.storage}</td><td>GB/pod</td></tr>
                        <tr><td>クラスター総ストレージ</td><td>${results.broker.totalStorage}</td><td>GB</td></tr>
                    </table>
                    <div class="explanation">
                        <h5>📋 計算根拠</h5>
                        <ul>
                            <li><strong>📊 基本処理量計算：</strong><br>
                                ${results.calculations.mirroringType === 'bidirectional' ? '入力値: ' + document.getElementById('messagesPerSecond').value + 'メッセージ/秒 × ' + document.getElementById('avgMessageSize').value + 'KB × 1024 = ' + Math.round(parseInt(document.getElementById('messagesPerSecond').value) * parseFloat(document.getElementById('avgMessageSize').value) / 1024 / 1024) + 'MB/秒<br>→ 双方向ミラーリング: ' + Math.round(parseInt(document.getElementById('messagesPerSecond').value) * parseFloat(document.getElementById('avgMessageSize').value) * 1024 / 1024) + 'MB/秒 × 2 = ' + Math.round(results.calculations.tCluster) + 'MB/秒' : document.getElementById('messagesPerSecond').value + 'メッセージ/秒 × ' + document.getElementById('avgMessageSize').value + 'KB × 1024 = ' + Math.round(results.calculations.bytesPerSecond / 1024) + 'KB/秒<br>→ ' + Math.round(results.calculations.bytesPerSecond / 1024 / 1024) + 'MB/秒'}
                            </li>
                            <li><strong>⚙️ p値（vCPU処理能力）計算：</strong><br>
                                ベース値: 20 MB/s/vCPU<br>
                                ${document.getElementById('avgMessageSize').value < 1 ? '→ 小型メッセージ調整: 20 × 0.5 = 10 MB/s/vCPU<br>' : document.getElementById('avgMessageSize').value > 10 ? '→ 大型メッセージ調整: 20 × 1.5 = 30 MB/s/vCPU<br>' : ''}
                                ${results.calculations.tlsEnabled ? '→ TLS暗号化調整: ' + (document.getElementById('avgMessageSize').value < 1 ? '10' : document.getElementById('avgMessageSize').value > 10 ? '30' : '20') + ' × 0.7 = ' + Math.round((document.getElementById('avgMessageSize').value < 1 ? 10 : document.getElementById('avgMessageSize').value > 10 ? 30 : 20) * 0.7 * 10) / 10 + ' MB/s/vCPU<br>' : ''}
                                ${results.calculations.compressionEnabled ? '→ 圧縮処理調整: ' + Math.round((results.calculations.tlsEnabled ? (document.getElementById('avgMessageSize').value < 1 ? 10 : document.getElementById('avgMessageSize').value > 10 ? 30 : 20) * 0.7 : (document.getElementById('avgMessageSize').value < 1 ? 10 : document.getElementById('avgMessageSize').value > 10 ? 30 : 20)) * 0.6 * 10) / 10 + ' MB/s/vCPU<br>' : ''}
                                <strong>最終p値: ${Math.round(results.calculations.pValue * 10) / 10} MB/s/vCPU</strong>
                            </li>
                            <li><strong>🏪 ブローカー台数決定プロセス：</strong><br>
                                <strong>制約1:</strong> パーティション制約<br>
                                　　(${results.calculations.actualTotalPartitions}パーティション × RF${document.getElementById('replicationFactor').value}) ÷ 4,000 = ${Math.round((results.calculations.actualTotalPartitions * parseInt(document.getElementById('replicationFactor').value)) / 4000 * 100) / 100} → ${results.calculations.brokersByPartitions}台<br>
                                <strong>制約2:</strong> ネットワーク制約<br>
                                　　ブローカー当たりNIC容量: ${results.calculations.nicBandwidthGbps}Gbps × 125MB/Gbps × 80% = ${Math.round(results.calculations.nicBandwidthGbps * 125 * 0.8)}MB/s<br>
                                　　実効容量: ${Math.round(results.calculations.nicBandwidthGbps * 125 * 0.8)}MB/s ÷ (${results.calculations.actualConsumerGroups}グループ + ${parseInt(document.getElementById('replicationFactor').value) - 1}レプリカ) = ${Math.round(results.calculations.capNIC_perBroker)}MB/s<br>
                                　　必要台数: ${Math.round(results.calculations.tCluster)}MB/s ÷ ${Math.round(results.calculations.capNIC_perBroker)}MB/s = ${results.calculations.brokersByNIC}台<br>
                                <strong>制約3:</strong> ディスクI/O制約<br>
                                　　ブローカー当たりディスク容量: ${results.calculations.diskThroughputMBps}MB/s × 70% = ${Math.round(results.calculations.diskThroughputMBps * 0.7)}MB/s<br>
                                　　実効容量: ${Math.round(results.calculations.diskThroughputMBps * 0.7)}MB/s ÷ RF${document.getElementById('replicationFactor').value} = ${Math.round(results.calculations.capDisk_perBroker)}MB/s<br>
                                　　必要台数: ${Math.round(results.calculations.tCluster)}MB/s ÷ ${Math.round(results.calculations.capDisk_perBroker)}MB/s = ${results.calculations.brokersByDisk}台<br>
                                <strong>決定:</strong> max(3, ${results.calculations.brokersByPartitions}, ${results.calculations.brokersByNIC}, ${results.calculations.brokersByDisk}) = <strong>${results.broker.pods}台</strong><br>
                                <strong>主要ボトルネック:</strong> ${results.calculations.bottleneckSource === 'partitions' ? 'パーティション数制約' : results.calculations.bottleneckSource === 'network' ? 'ネットワーク帯域幅制約' : 'ディスクI/O制約'}
                            </li>
                            <li><strong>💾 CPU計算プロセス：</strong><br>
                                ブローカー当たり処理量: ${Math.round(results.calculations.tCluster)}MB/s ÷ ${results.broker.pods}台 = ${Math.round(results.calculations.tBroker * 100) / 100}MB/s/台<br>
                                基本必要CPU: ${Math.round(results.calculations.tBroker * 100) / 100}MB/s ÷ ${Math.round(results.calculations.pValue * 10) / 10}MB/s/vCPU = ${Math.round(results.calculations.tBroker / results.calculations.pValue * 100) / 100}vCPU<br>
                                安全率適用: ${Math.round(results.calculations.tBroker / results.calculations.pValue * 100) / 100}vCPU ÷ 0.6(60%利用率) = ${Math.round(results.calculations.tBroker / (results.calculations.pValue * 0.6) * 100) / 100}vCPU<br>
                                切り上げ: ceil(${Math.round(results.calculations.tBroker / (results.calculations.pValue * 0.6) * 100) / 100}) = ${Math.ceil(results.calculations.tBroker / (results.calculations.pValue * 0.6))}vCPU<br>
                                <strong>最終CPU:</strong> max(4vCPU, ${Math.ceil(results.calculations.tBroker / (results.calculations.pValue * 0.6))}vCPU) = <strong>${results.broker.cpu}vCPU</strong>
                            </li>
                            <li><strong>🧠 メモリ計算プロセス：</strong><br>
                                JVMヒープ: ${results.calculations.jvmHeap}GB (固定推奨値)<br>
                                ${results.calculations.tlsEnabled ? 'TLS直接バッファ: ' + results.calculations.jvmHeap + 'GB × 10% = ' + Math.round(results.calculations.jvmHeap * 0.1 * 10) / 10 + 'GB<br>' : ''}
                                ${results.calculations.compressionEnabled ? '圧縮直接バッファ: ' + results.calculations.jvmHeap + 'GB × 10% = ' + Math.round(results.calculations.jvmHeap * 0.1 * 10) / 10 + 'GB<br>' : ''}
                                ページキャッシュ: ${Math.round(results.calculations.tBroker * 100) / 100}MB/s × ${results.calculations.cacheMinutes}分 × 60秒 ÷ 1024 = ${Math.round(results.calculations.requiredPageCache * 100) / 100}GB<br>
                                小計: ${results.calculations.jvmHeap}GB + ${Math.round(results.calculations.directBufferOverhead * 10) / 10}GB + ${Math.round(results.calculations.requiredPageCache * 10) / 10}GB = ${Math.round(results.calculations.baseMemory * 10) / 10}GB<br>
                                OS余裕: ${Math.round(results.calculations.baseMemory * 10) / 10}GB × 10% = ${Math.round(results.calculations.baseMemory * 0.1 * 10) / 10}GB<br>
                                計算値: ${Math.round(results.calculations.baseMemory * 10) / 10}GB + ${Math.round(results.calculations.baseMemory * 0.1 * 10) / 10}GB = ${results.calculations.calculatedMemory}GB<br>
                                <strong>計算結果:</strong> <strong>${results.broker.memory}GB</strong><br>
                                ※ 高負荷プロダクション環境では32-64GB推奨
                            </li>
                            <li><strong>💽 ストレージ計算プロセス：</strong><br>
                                日次データ量: ${Math.round(results.calculations.tCluster)}MB/s × 86,400秒 ÷ 1,024 = ${Math.round(results.calculations.dailyDataGB * 100) / 100}GB/日<br>
                                保持期間データ: ${Math.round(results.calculations.dailyDataGB * 100) / 100}GB/日 × ${document.getElementById('retentionDays').value}日 = ${Math.round(results.calculations.dailyDataGB * parseInt(document.getElementById('retentionDays').value) * 100) / 100}GB<br>
                                レプリケーション: ${Math.round(results.calculations.dailyDataGB * parseInt(document.getElementById('retentionDays').value) * 100) / 100}GB × RF${document.getElementById('replicationFactor').value} = ${Math.round(results.calculations.totalStorageGB)}GB<br>
                                ブローカー当たり: ${Math.round(results.calculations.totalStorageGB)}GB ÷ ${results.broker.pods}台 = ${Math.round(results.calculations.totalStorageGB / results.broker.pods)}GB<br>
                                使用率考慮: ${Math.round(results.calculations.totalStorageGB / results.broker.pods)}GB ÷ 0.85(85%制限) = ${Math.round(results.calculations.totalStorageGB / results.broker.pods / 0.85)}GB<br>
                                <strong>最終ストレージ:</strong> <strong>${results.broker.storage}GB/ブローカー</strong>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="result-section">
                    <h4>🔄 MirrorMaker2</h4>
                    <table class="resource-table">
                        <tr><th>リソース</th><th>値</th><th>単位</th></tr>
                        <tr><td>インスタンス数</td><td>${results.mm2.instances}</td><td>個 (${results.calculations.mirroringType === 'bidirectional' ? '双方向' : '単方向'})</td></tr>
                        <tr><td>ワーカー数/インスタンス</td><td>${results.mm2.workersPerInstance}</td><td>pod/インスタンス</td></tr>
                        <tr><td>総Pod数（方向当たり）</td><td>${results.mm2.workersPerInstance}</td><td>個</td></tr>
                        <tr><td>tasks.max</td><td>${results.mm2.tasksMax}</td><td>個/インスタンス</td></tr>
                        <tr><td>CPU (Request)</td><td>${results.mm2.cpuPerWorker}</td><td>vCPU/pod</td></tr>
                        <tr><td>CPU (Limit)</td><td>${Math.ceil(results.mm2.cpuPerWorker * 1.5)}</td><td>vCPU/pod</td></tr>
                        <tr><td>メモリ (Request)</td><td>${results.mm2.memory}</td><td>GB/pod</td></tr>
                        <tr><td>メモリ (Limit)</td><td>${Math.ceil(results.mm2.memory * 1.5)}</td><td>GB/pod</td></tr>
                    </table>
                    <div class="explanation">
                        <h5>📋 計算根拠</h5>
                        <ul>
                            <li><strong>🔄 MM2インスタンス構成：</strong><br>
                                ${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリング: 2インスタンス (Blue→Green + Green→Blue)<br>各方向は独立動作、リソースは単方向基準で計算' : '単方向ミラーリング: 1インスタンス (単一方向)'}
                            </li>
                            <li><strong>👥 ワーカー配置：</strong><br>
                                ${results.mm2.workersPerInstance}ワーカー/インスタンス (高可用性のため2台推奨)<br>
                                総ワーカー数: ${results.mm2.workersPerInstance}個/方向
                            </li>
                            <li><strong>📊 MM2処理量計算：</strong><br>
                                入力処理量: ${document.getElementById('messagesPerSecond').value}メッセージ/秒 × ${document.getElementById('avgMessageSize').value}KB ÷ 1024 = ${Math.round(results.calculations.mm2ProcessingLoad * 100) / 100}MB/秒<br>
                                ※ MM2は入力値のみ処理（複製トラフィック除外）
                            </li>
                            <li><strong>⚙️ MM2 p値（同一DC内基準）：</strong><br>
                                ベース値: 15 MB/s/vCPU<br>
                                ${results.calculations.tlsEnabled && results.calculations.compressionEnabled ? 'TLS+圧縮使用: 15 × 0.4 = 6 MB/s/vCPU<br>' : results.calculations.tlsEnabled ? 'TLS使用: 15 × 0.67 ≈ 10 MB/s/vCPU<br>' : results.calculations.compressionEnabled ? '圧縮使用: 15 × 0.67 ≈ 10 MB/s/vCPU<br>' : '標準設定: 15 MB/s/vCPU<br>'}
                                <strong>最終MM2 p値: ${Math.round(results.calculations.mm2PValue * 10) / 10} MB/s/vCPU</strong>
                            </li>
                            <li><strong>💾 MM2 CPU計算プロセス：</strong><br>
                                基本必要CPU: ${Math.round(results.calculations.mm2ProcessingLoad * 100) / 100}MB/s ÷ ${Math.round(results.calculations.mm2PValue * 10) / 10}MB/s/vCPU = ${Math.round(results.calculations.mm2ProcessingLoad / results.calculations.mm2PValue * 100) / 100}vCPU<br>
                                安全率適用: ${Math.round(results.calculations.mm2ProcessingLoad / results.calculations.mm2PValue * 100) / 100}vCPU ÷ 0.6(60%利用率) = ${Math.round(results.calculations.mm2ProcessingLoad / (results.calculations.mm2PValue * 0.6) * 100) / 100}vCPU<br>
                                切り上げ: ceil(${Math.round(results.calculations.mm2ProcessingLoad / (results.calculations.mm2PValue * 0.6) * 100) / 100}) = ${results.calculations.mm2RequiredTotalCPU}vCPU（必要総CPU）
                            </li>
                            <li><strong>👤 Pod当たりCPU設定：</strong><br>
                                計算値: ${results.calculations.mm2RequiredTotalCPU}vCPU ÷ ${results.mm2.workersPerInstance}ワーカー = ${Math.round(results.calculations.mm2CPUPerWorkerCalculated * 100) / 100}vCPU/Pod<br>
                                <strong>Pod当たりCPU:</strong> max(2vCPU, ${Math.round(results.calculations.mm2CPUPerWorkerCalculated * 100) / 100}vCPU) = <strong>${results.mm2.cpuPerWorker}vCPU/Pod</strong><br>
                                <strong>実際の総CPU:</strong> ${results.mm2.cpuPerWorker}vCPU × ${results.mm2.workersPerInstance}Pod = <strong>${results.mm2.totalCPU}vCPU</strong>
                            </li>
                            <li><strong>⚡ tasks.max計算：</strong><br>
                                複製対象パーティション数: ${document.getElementById('totalPartitions').value}<br>
                                MM2総CPU数: ${results.mm2.totalCPU}vCPU<br>
                                <strong>tasks.max:</strong> min(${document.getElementById('totalPartitions').value}, ${results.mm2.totalCPU}) = <strong>${results.mm2.tasksMax}</strong><br>
                                ※ 1CPU当たり1タスクが理想的な並列度
                            </li>
                            <li><strong>🧠 MM2メモリ計算（実運用基準）：</strong><br>
                                JVMヒープ: max(2GB, 0.5GB × ${results.mm2.tasksMax}tasks) = ${Math.round(results.calculations.mm2HeapSize * 100) / 100}GB<br>
                                直接バッファ: ${Math.round(results.calculations.mm2HeapSize * 100) / 100}GB × 20% = ${Math.round(results.calculations.mm2DirectBuffer * 100) / 100}GB (Netty + TLS)<br>
                                OS·カーネル: ${results.calculations.mm2OSOverhead}GB (固定)<br>
                                小計: ${Math.round(results.calculations.mm2HeapSize * 100) / 100}GB + ${Math.round(results.calculations.mm2DirectBuffer * 100) / 100}GB + ${results.calculations.mm2OSOverhead}GB = ${Math.round(results.calculations.mm2BaseMemory * 100) / 100}GB<br>
                                安全余裕: ${Math.round(results.calculations.mm2BaseMemory * 100) / 100}GB × 10% = ${Math.round(results.calculations.mm2BaseMemory * 0.1 * 100) / 100}GB<br>
                                <strong>最終メモリ:</strong> ceil(${Math.round(results.calculations.mm2BaseMemory * 1.1 * 100) / 100}GB) = <strong>${results.mm2.memory}GB/ワーカー</strong><br>
                                ※ オープンソースMM2直接運用基準（AWS MCU 4GB/vCPUより節約的）
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="result-section">
                    <h4>📊 計算サマリー</h4>
                    <table class="resource-table">
                        <tr><th>項目</th><th>入力値</th><th>調整後の値</th><th>説明</th></tr>
                        <tr><td>メッセージ処理量</td><td>${document.getElementById('messagesPerSecond').value}/秒</td><td>${results.calculations.actualMessagesPerSecond}/秒</td><td>${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリングのため2倍' : '単方向のため変更なし'}</td></tr>
                        <tr><td>総パーティション数</td><td>${document.getElementById('totalPartitions').value}</td><td>${results.calculations.actualTotalPartitions}</td><td>${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリングのため2倍' : '単方向のため変更なし'}</td></tr>
                        <tr><td>コンシューマーグループ数</td><td>${document.getElementById('consumerGroups').value}</td><td>${results.calculations.actualConsumerGroups}</td><td>MM2を1つのコンシューマーグループとして追加</td></tr>
                        <tr><td>日次データ量</td><td>-</td><td>${Math.round(results.calculations.dailyDataGB)}GB</td><td>${Math.round(results.calculations.tCluster)}MB/s × 86400秒 ÷ 1024 = ${Math.round(results.calculations.dailyDataGB)}GB</td></tr>
                        <tr><td>必要総ストレージ</td><td>-</td><td>${Math.round(results.calculations.totalStorageGB)}GB</td><td>${Math.round(results.calculations.dailyDataGB)}GB × ${document.getElementById('retentionDays').value}日 × RF${document.getElementById('replicationFactor').value} = ${Math.round(results.calculations.totalStorageGB)}GB</td></tr>
                    </table>
                </div>

                <div class="result-section">
                    <h4>⚠️ 重要な免責事項と運用上の注意事項</h4>
                    <div class="warning" style="background: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #dc3545;">
                        <strong>📢 この計算結果について</strong><br>
                        上記の計算結果は<strong>参考値・概算値</strong>であり、正確な最終回答ではありません。Kafka と MirrorMaker2 導入時に<strong>「どの程度のリソースが必要か」を把握するための目安</strong>としてご活用ください。実際のプロダクション環境では、これらの値を出発点として必ず負荷テストとモニタリングによる調整を行ってください。
                    </div>
                    <div class="explanation">
                        <ul>
                            <li><strong>ディスク使用率：</strong> 85%を超えないよう監視し、必要に応じてストレージを増設してください</li>
                            <li><strong>CPU使用率：</strong> 平常時60%以下を維持し、ピーク時の負荷に備えてください</li>
                            <li><strong>メモリ使用率：</strong> JVMヒープは総メモリの25%以下に抑え、残りをページキャッシュとして活用してください</li>
                            <li><strong>ネットワーク：</strong> 各ブローカーが${Math.round(results.calculations.bytesPerSecond / results.broker.pods / 1024 / 1024)}MB/s程度の処理を行うため、十分なネットワーク帯域を確保してください</li>
                            <li><strong>負荷テスト：</strong> 本計算結果を出発点として実際の負荷テストを行い、環境に応じて必ず調整してください</li>
                            <li><strong>継続的モニタリング：</strong> 実際の使用量を継続的に監視し、必要に応じてリソースを調整してください</li>
                        </ul>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

    </script>
</body>
</html>
