<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka & MirrorMaker2 リソース計算機</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab:hover {
            background: #e9ecef;
        }

        .tab.active:hover {
            background: #5a6fd8;
        }

        .tab-content {
            display: none;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tab-content.active {
            display: block;
        }

        .form-section {
            margin-bottom: 30px;
        }

        .form-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group small {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.9rem;
        }

        .calculate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 20px;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .results {
            margin-top: 30px;
        }

        .result-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .result-section h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .resource-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .resource-table th, .resource-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .resource-table th {
            background-color: #667eea;
            color: white;
            font-weight: 600;
        }

        .resource-table tr:hover {
            background-color: #f1f3f4;
        }

        .explanation {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 4px solid #2196f3;
        }

        .explanation h5 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .explanation ul {
            padding-left: 20px;
        }

        .explanation li {
            margin-bottom: 5px;
        }

        .knowledge-section {
            margin-bottom: 30px;
        }

        .knowledge-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.4rem;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .knowledge-content {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            line-height: 1.7;
        }

        .knowledge-content h4 {
            color: #495057;
            margin: 20px 0 10px 0;
        }

        .knowledge-content ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .knowledge-content li {
            margin-bottom: 8px;
        }

        .formula {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
            font-family: monospace;
            font-size: 0.95rem;
        }

        .warning {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #dc3545;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #17a2b8;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                border-bottom: 1px solid #dee2e6;
            }
            
            .tab:last-child {
                border-bottom: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Kafka & MirrorMaker2 リソース計算機</h1>
            <p>KRaftモード対応 - Kubernetesデプロイメント用のリソース算定ツール</p>
            <div class="warning" style="background: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; margin-top: 15px; border-left: 4px solid #dc3545;">
                <strong>⚠️ 重要な注意事項</strong><br>
                本ツールの計算結果は参考値であり、正確な最終回答ではありません。Kafka と MirrorMaker2 導入時のリソース量を概算するための目安としてご利用ください。実際の環境では必ず負荷テストとモニタリングによる調整が必要です。
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="openTab(event, 'calculator')">リソース計算</button>
            <button class="tab" onclick="openTab(event, 'knowledge')">ベース知識</button>
        </div>

        <div id="calculator" class="tab-content active">
            <form id="calculatorForm">
                <div class="form-section">
                    <h3>基本パラメータ</h3>
                    
                    <div class="form-group">
                        <label for="messagesPerSecond">メッセージ処理量（メッセージ/秒）</label>
                        <input type="number" id="messagesPerSecond" name="messagesPerSecond" value="10000" min="1" required>
                        <small>クラスターに流入する平均またはピークメッセージ数。MirrorMaker2による複製トラフィックは無視して入力してください（自動で計算に含まれます）。</small>
                    </div>

                    <div class="form-group">
                        <label for="avgMessageSize">平均メッセージサイズ（KB）</label>
                        <input type="number" id="avgMessageSize" name="avgMessageSize" value="1" min="0.1" step="0.1" required>
                        <small>各メッセージの平均サイズ。処理量と掛け合わせて秒間データ量を計算します。</small>
                    </div>

                    <div class="form-group">
                        <label for="totalPartitions">総パーティション数</label>
                        <input type="number" id="totalPartitions" name="totalPartitions" value="1000" min="1" required>
                        <small>すべてのトピックのパーティション数の合計。双方向ミラーリングの場合は複製トピックが追加されるため、実際のパーティション数は2倍として計算されます。MirrorMaker2による複製パーティションは無視して入力してください。</small>
                    </div>

                    <div class="form-group">
                        <label for="retentionDays">メッセージ保管期間（日）</label>
                        <input type="number" id="retentionDays" name="retentionDays" value="7" min="1" required>
                        <small>データがクラスターに保存される期間。ストレージ容量計算に使用されます。</small>
                    </div>

                    <div class="form-group">
                        <label for="replicationFactor">レプリケーションファクター</label>
                        <input type="number" id="replicationFactor" name="replicationFactor" value="3" min="1" max="7" required>
                        <small>各トピックの複製本数。通常は3を推奨します。</small>
                    </div>

                    <div class="form-group">
                        <label for="consumerGroups">コンシューマーグループ数</label>
                        <input type="number" id="consumerGroups" name="consumerGroups" value="2" min="1" required>
                        <small>同時に同じデータを購読する独立したコンシューマーグループの数。MirrorMaker2も1つのコンシューマーグループとして計算されます。</small>
                    </div>
                </div>

                <div class="form-section">
                    <h3>MirrorMaker2設定</h3>
                    
                    <div class="form-group">
                        <label for="mirroringType">ミラーリングタイプ</label>
                        <select id="mirroringType" name="mirroringType" required>
                            <option value="bidirectional">双方向 (Blue ⇄ Green)</option>
                            <option value="unidirectional">単方向 (Blue → Green)</option>
                        </select>
                        <small>単方向同期を実施している場合は単方向を選択してください。</small>
                    </div>

                    <div class="form-group">
                        <label for="compressionEnabled">圧縮使用</label>
                        <select id="compressionEnabled" name="compressionEnabled" required>
                            <option value="false">なし</option>
                            <option value="true">あり（CPU使用量増加）</option>
                        </select>
                        <small>メッセージ圧縮を使用する場合、CPU使用量が増加します。</small>
                    </div>

                    <div class="form-group">
                        <label for="tlsEnabled">TLS暗号化使用</label>
                        <select id="tlsEnabled" name="tlsEnabled" required>
                            <option value="false">なし</option>
                            <option value="true">あり（CPU使用量増加）</option>
                        </select>
                        <small>TLS暗号化を使用する場合、CPU使用量が増加します。</small>
                    </div>
                </div>

                <button type="submit" class="calculate-btn">リソースを計算する</button>
            </form>

            <div id="results" class="results" style="display: none;"></div>
        </div>

        <div id="knowledge" class="tab-content">
            <div class="knowledge-section">
                <h3>入力パラメータの詳細説明</h3>
                <div class="knowledge-content">
                    <h4>1. メッセージ処理量（メッセージ/秒）</h4>
                    <p>クラスターに流入する平均またはピークメッセージ数を意味します。これにより秒間バイト処理量を計算できます（例：msgs_per_sec × avg_msg_size）。</p>
                    <div class="info">
                        <strong>双方向ミラーリングの自動計算：</strong><br>
                        MirrorMaker2による複製トラフィックは無視して入力してください。双方向ミラーリングの場合、各クラスターには入力したデータとMirrorMaker2による複製データが共存するため、実際の処理量は入力値の2倍として自動計算されます。
                    </div>

                    <h4>2. 平均メッセージサイズ（KB）</h4>
                    <p>各メッセージの平均サイズです。メッセージサイズと処理量を掛けて秒間データ量（例：MB/s）を計算し、ディスクおよびネットワーク容量計算に使用します。</p>
                    <div class="formula">
                        例：平均1KBメッセージを秒間10,000件処理 = 約10MB/sのデータ率
                    </div>

                    <h4>3. 総パーティション数</h4>
                    <p>すべてのトピックのパーティション数の合計です。MirrorMaker2による複製パーティションは無視して入力してください。</p>
                    <div class="warning">
                        <strong>重要：</strong> 双方向ミラーリングの場合、複製トピックが追加されるため実際のパーティション数は2倍として自動計算されます。この値はリーダー+フォロワーレプリカを全て含んだパーティション総計として計算されます。
                    </div>

                    <h4>4. メッセージ保管期間（日）</h4>
                    <p>データがクラスターに保存される期間で、与えられたretention期間中に保存される総データ量を計算するのに必要です。</p>
                    <div class="formula">
                        例：日次データ流入量1TB、保管期間7日 → 最低7TBのストレージ必要（レプリカファクターおよび余裕容量除く）
                    </div>

                    <h4>5. レプリケーションファクター</h4>
                    <p>各トピックの複製本数です（例：3）。レプリケーションファクターがrの場合、1つのメッセージがクラスター内r個のブローカーに保存されるため、保存容量および内部複製トラフィックがr倍増加します。</p>

                    <h4>6. コンシューマーグループ数</h4>
                    <p>同時に同じデータを購読する独立したコンシューマーグループの数です。コンシューマーグループが多いほどブローカーのアウトバウンドトラフィックが増加します。</p>
                    <div class="info">
                        <strong>MirrorMaker2の考慮：</strong><br>
                        MirrorMaker2もソースクラスター側では1つのコンシューマーグループとして動作するため、MM2による負荷を計算に含める必要があります。
                    </div>
                </div>
            </div>

            <div class="knowledge-section">
                <h3>リソース計算の根拠</h3>
                <div class="knowledge-content">
                    <h4>Kafka コントローラー（KRaftモード）</h4>
                    <ul>
                        <li><strong>Pod数：</strong> KRaftコントローラーは2n+1の奇数個で構成し、過半数投票による可用性を確保します。プロダクション環境では最低3台（典型的には3台、必要に応じて5台）を推奨</li>
                        <li><strong>CPU：</strong> コントローラー1台当たり約4 vCPUを割り当て。メタデータ管理が主な役割ですが、安定動作のため十分なCPUリソースを確保</li>
                        <li><strong>メモリ：</strong> メタデータログ保持のため約4GB。JVMヒープは1GB程度で十分（Kafkaはコントローラーに大容量ヒープを要求しません）</li>
                        <li><strong>ストレージ：</strong> 高速SSDが必須。Confluent推奨はコントローラー1台当たり約64GB SSD。メタデータ専用として信頼性と速度の高いディスクが必要</li>
                    </ul>

                    <h4>Kafka ブローカー</h4>
                    <ul>
                        <li><strong>Pod数：</strong> 
                            <ul>
                                <li>パーティション制約：1ブローカー当たり最大約4,000個まで推奨</li>
                                <li>スループット制約：ブローカー当たりの最大処理能力を考慮</li>
                                <li>例：3ノード・RF=3・2消費グループのクラスターでは理論上800MB/s程度が上限、本番では80%程度（640MB/s）に抑制推奨</li>
                            </ul>
                        </li>
                        <li><strong>CPU：</strong> 
                            <ul>
                                <li>一般的にブローカー当たり4〜8 vCPU（request）、最大24 vCPUまでスケールアップ</li>
                                <li>多くのKafka本番クラスターでは1台当たり24コア程度を使用</li>
                                <li>CPUクロックよりもコア数を重視し、並行処理能力で高スループットを実現</li>
                            </ul>
                        </li>
                        <li><strong>メモリ：</strong> 
                            <ul>
                                <li>JVMヒープは6GB以下に抑制（Kafkaはヒープを慎重に使用）</li>
                                <li>残りメモリは全てOSページキャッシュとして活用</li>
                                <li>推奨：ブローカー1台当たり32〜64GB（64GB RAMサーバーが理想的）</li>
                                <li>例：総メモリ32GBでヒープ6GBの場合、約26GBをディスクキャッシュに充当</li>
                            </ul>
                        </li>
                        <li><strong>ストレージ：</strong> 
                            <ul>
                                <li>計算式：日次データ流入量 × 保管日数 × レプリカ係数 ÷ ブローカー数</li>
                                <li>重要：ディスク使用率85%以下を維持（余裕率15%確保）</li>
                                <li>例：日次1TB × 7日 × RF3 = 21TB → 85%ルール適用で約24.7TB必要</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>MirrorMaker2（クロスデータセンター複製）</h4>
                    <ul>
                        <li><strong>Pod数：</strong> 
                            <ul>
                                <li>Kafka Connectフレームワーク上で動作、高可用性のため最低2つ以上のワーカーノード</li>
                                <li>双方向同期（Active-Active）では各方向に別個のコネクターが必要</li>
                            </ul>
                        </li>
                        <li><strong>tasks.max：</strong> 
                            <ul>
                                <li>理想設定：min(複製元パーティション総数, 利用可能CPUコア数)</li>
                                <li>1タスクにつき1コア程度を割り当てる想定で計画</li>
                                <li>例：ソース10パーティション、8CPUコアの場合 → tasks.max = 8</li>
                            </ul>
                        </li>
                        <li><strong>CPU：</strong> 
                            <ul>
                                <li>基本：ワーカー当たり1〜2 vCPU</li>
                                <li>高負荷環境：各ワーカー当たり4 vCPU以上</li>
                                <li>プロデューサー・コンシューマー両方の処理負荷を考慮</li>
                            </ul>
                        </li>
                        <li><strong>メモリ：</strong> JVMヒープ1〜4GB程度、バッファリングを考慮してCPU当たり0.5GB配分が目安</li>
                    </ul>
                </div>
            </div>

            <div class="knowledge-section">
                <h3>計算式の詳細</h3>
                <div class="knowledge-content">
                    <h4>ブローカー数の計算</h4>
                    <div class="formula">
                        ブローカー数 = max(
                            ceil((総パーティション数 × レプリケーションファクター) / 4000),
                            ceil(処理量要件による必要数)
                        )
                    </div>

                    <h4>ストレージ容量の計算</h4>
                    <div class="formula">
                        ブローカー当たり必要容量 = 
                        (日別入力データ量 × 保管日数 × レプリケーションファクター) / ブローカー数 / 0.85
                        
                        ※ 0.85は85%使用率制限を考慮した余裕率
                    </div>

                    <h4>メモリ計算（ページキャッシュ）</h4>
                    <div class="formula">
                        推奨メモリ = JVMヒープ + (30秒分のデータ量をキャッシュできる容量)
                        
                        30秒分データ量 = (メッセージ/秒 × 平均サイズ × 30) / ブローカー数
                    </div>

                    <h4>MM2 tasks.max の計算</h4>
                    <div class="formula">
                        tasks.max = min(複製対象パーティション数, 利用可能な総vCPU数)
                        
                        ※ CPU1コア当たり1タスクが理想的
                    </div>
                </div>
            </div>

            <div class="knowledge-section">
                <h3>参考文献・出典</h3>
                <div class="knowledge-content">
                    <h4>公式ドキュメント</h4>
                    <ul>
                        <li><a href="https://docs.confluent.io/platform/current/kafka-metadata/config-kraft.html" target="_blank">Configure and Monitor KRaft | Confluent Documentation</a></li>
                        <li><a href="https://docs.confluent.io/platform/current/installation/system-requirements.html" target="_blank">Confluent Platform System Requirements | Confluent Documentation</a></li>
                        <li><a href="https://docs.confluent.io/platform/6.1/kafka/deployment.html" target="_blank">Running Kafka in Production | Confluent Documentation</a></li>
                        <li><a href="https://docs.aws.amazon.com/msk/latest/developerguide/bestpractices.html" target="_blank">Best practices for Standard brokers - Amazon Managed Streaming for Apache Kafka</a></li>
                    </ul>

                    <h4>技術ブログ・ベストプラクティス</h4>
                    <ul>
                        <li><a href="https://aws.amazon.com/blogs/big-data/best-practices-for-right-sizing-your-apache-kafka-clusters-to-optimize-performance-and-cost/" target="_blank">Best practices for right-sizing your Apache Kafka clusters to optimize performance and cost | AWS Big Data Blog</a></li>
                        <li><a href="https://www.confluent.io/blog/apache-kafka-supports-200k-partitions-per-cluster/" target="_blank">Apache Kafka Supports 200K Partitions Per Cluster | Confluent</a></li>
                        <li><a href="https://www.instaclustr.com/blog/how-to-size-apache-kafka-clusters-for-tiered-storage-part-3/" target="_blank">How to size Apache Kafka® clusters for Tiered Storage: Part 3 - Instaclustr</a></li>
                    </ul>

                    <h4>MirrorMaker2関連</h4>
                    <ul>
                        <li><a href="https://aiven.io/docs/products/kafka/kafka-mirrormaker/concepts/disaster-recovery/active-active-setup" target="_blank">MirrorMaker 2 active-active setup | Aiven docs</a></li>
                        <li><a href="https://www.instaclustr.com/blog/apache-kafka-mirrormaker-2-practice/" target="_blank">Apache Kafka MirrorMaker 2 (MM2) Part 2: Practice</a></li>
                        <li><a href="https://cloud.google.com/managed-service-for-apache-kafka/docs/connect-cluster/create-mirrormaker-connector" target="_blank">Create a MirrorMaker 2.0 connector | Google Cloud Managed Service for Apache Kafka</a></li>
                        <li><a href="https://aiven.io/docs/products/kafka/kafka-mirrormaker/reference/advanced-params" target="_blank">Advanced parameters for Aiven for Apache Kafka® MirrorMaker 2 | Aiven docs</a></li>
                        <li><a href="https://www.redpanda.com/guides/kafka-alternatives-kafka-mirrormaker" target="_blank">Kafka MirrorMaker—Tutorial, best practices and alternatives</a></li>
                    </ul>

                    <div class="info">
                        <strong>注意事項：</strong><br>
                        本計算ツールは上記の信頼できるソースに基づいて作成されていますが、実際の環境では必ず負荷テストとモニタリングによる調整を行ってください。リソース要件は具体的なワークロードと環境に大きく依存します。
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function openTab(evt, tabName) {
            var i, tabcontent, tabs;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].classList.remove("active");
            }
            tabs = document.getElementsByClassName("tab");
            for (i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove("active");
            }
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
        }

        document.getElementById('calculatorForm').addEventListener('submit', function(e) {
            e.preventDefault();
            calculateResources();
        });

        function calculateResources() {
            // 入力値を取得
            const messagesPerSecond = parseInt(document.getElementById('messagesPerSecond').value);
            const avgMessageSize = parseFloat(document.getElementById('avgMessageSize').value);
            const totalPartitions = parseInt(document.getElementById('totalPartitions').value);
            const retentionDays = parseInt(document.getElementById('retentionDays').value);
            const replicationFactor = parseInt(document.getElementById('replicationFactor').value);
            const consumerGroups = parseInt(document.getElementById('consumerGroups').value);
            const mirroringType = document.getElementById('mirroringType').value;
            const compressionEnabled = document.getElementById('compressionEnabled').value === 'true';
            const tlsEnabled = document.getElementById('tlsEnabled').value === 'true';

            // 双方向ミラーリングの場合の調整
            const actualMessagesPerSecond = mirroringType === 'bidirectional' ? messagesPerSecond * 2 : messagesPerSecond;
            const actualTotalPartitions = mirroringType === 'bidirectional' ? totalPartitions * 2 : totalPartitions;
            const actualConsumerGroups = consumerGroups + 1; // MM2を1つのコンシューマーグループとして追加

            // 基本計算
            const bytesPerSecond = actualMessagesPerSecond * avgMessageSize * 1024; // KB to bytes
            const dailyDataGB = (bytesPerSecond * 86400) / (1024 * 1024 * 1024); // GB/day
            const totalStorageGB = dailyDataGB * retentionDays * replicationFactor;

            // コントローラー計算
            const controllerPods = 3; // 推奨値
            const controllerCPU = 4; // vCPU per pod
            const controllerMemory = 4; // GB per pod
            const controllerStorage = 64; // GB per pod

            // ブローカー計算
            const brokersByPartitions = Math.ceil((actualTotalPartitions * replicationFactor) / 4000);
            
            // 改善されたスループット計算：3ノード・RF=3・2消費グループで800MB/s理論値、80%で640MB/s実用値を基準
            // この基準から各ブローカーの実効スループットを約213MB/s (640/3) と推定
            const brokerThroughputMBps = 213; // MB/s per broker (実測ベース)
            const safetyFactor = 0.8; // 80%安全率
            const effectiveThroughputPerBroker = brokerThroughputMBps * safetyFactor; // 約170MB/s
            
            const brokersByThroughput = Math.ceil((bytesPerSecond / 1024 / 1024) / effectiveThroughputPerBroker);
            const brokerPods = Math.max(3, Math.max(brokersByPartitions, brokersByThroughput)); // 最小3台

            let brokerCPU = 8; // base vCPU per broker
            if (compressionEnabled) brokerCPU += 4;
            if (tlsEnabled) brokerCPU += 4;

            const cachingMemoryGB = Math.max(2, (bytesPerSecond * 30) / (1024 * 1024 * 1024) / brokerPods); // 30秒分キャッシュ
            const brokerMemory = Math.max(32, 6 + cachingMemoryGB); // JVMヒープ6GB + キャッシュ用メモリ
            const brokerStoragePerPod = Math.ceil((totalStorageGB / brokerPods) / 0.85); // 85%利用率考慮

            // MM2計算
            const mm2Instances = mirroringType === 'bidirectional' ? 2 : 1;
            const mm2WorkersPerInstance = 2; // 推奨値
            const mm2TotalWorkers = mm2Instances * mm2WorkersPerInstance;
            
            const tasksMax = Math.min(totalPartitions, brokerPods * brokerCPU);
            let mm2CPU = Math.max(2, Math.ceil(tasksMax / mm2WorkersPerInstance));
            if (compressionEnabled) mm2CPU += 1;
            if (tlsEnabled) mm2CPU += 1;
            
            const mm2Memory = Math.max(2, Math.ceil(mm2CPU * 0.5)); // CPU依存

            // 結果表示
            displayResults({
                controller: {
                    pods: controllerPods,
                    cpu: controllerCPU,
                    memory: controllerMemory,
                    storage: controllerStorage
                },
                broker: {
                    pods: brokerPods,
                    cpu: brokerCPU,
                    memory: brokerMemory,
                    storage: brokerStoragePerPod,
                    totalStorage: Math.ceil(totalStorageGB / 0.85)
                },
                mm2: {
                    instances: mm2Instances,
                    workersPerInstance: mm2WorkersPerInstance,
                    totalWorkers: mm2TotalWorkers,
                    cpu: mm2CPU,
                    memory: mm2Memory,
                    tasksMax: tasksMax
                },
                calculations: {
                    actualMessagesPerSecond,
                    actualTotalPartitions,
                    actualConsumerGroups,
                    bytesPerSecond,
                    dailyDataGB,
                    totalStorageGB,
                    brokersByPartitions,
                    brokersByThroughput,
                    mirroringType,
                    compressionEnabled,
                    tlsEnabled
                }
            });
        }

        function displayResults(results) {
            const resultsDiv = document.getElementById('results');
            
            resultsDiv.innerHTML = `
                <div class="result-section">
                    <h4>🎛️ Kafka コントローラー</h4>
                    <table class="resource-table">
                        <tr><th>リソース</th><th>値</th><th>単位</th></tr>
                        <tr><td>Pod数</td><td>${results.controller.pods}</td><td>個</td></tr>
                        <tr><td>CPU (Request/Limit)</td><td>${results.controller.cpu}</td><td>vCPU/pod</td></tr>
                        <tr><td>メモリ (Request/Limit)</td><td>${results.controller.memory}</td><td>GB/pod</td></tr>
                        <tr><td>ストレージ (PVC)</td><td>${results.controller.storage}</td><td>GB/pod</td></tr>
                    </table>
                    <div class="explanation">
                        <h5>📋 計算根拠</h5>
                        <ul>
                            <li>KRaftモードでは高可用性のために奇数個（通常3個）のコントローラーが必要</li>
                            <li>Confluent推奨仕様：コントローラー当たり4vCPU、4GBメモリ、64GB SSD</li>
                            <li>メタデータログの保存と管理が主な役割のため、比較的軽量な構成</li>
                        </ul>
                    </div>
                </div>

                <div class="result-section">
                    <h4>🏪 Kafka ブローカー</h4>
                    <table class="resource-table">
                        <tr><th>リソース</th><th>値</th><th>単位</th></tr>
                        <tr><td>Pod数</td><td>${results.broker.pods}</td><td>個</td></tr>
                        <tr><td>CPU (Request)</td><td>${results.broker.cpu}</td><td>vCPU/pod</td></tr>
                        <tr><td>CPU (Limit)</td><td>${Math.ceil(results.broker.cpu * 1.5)}</td><td>vCPU/pod</td></tr>
                        <tr><td>メモリ (Request)</td><td>${results.broker.memory}</td><td>GB/pod</td></tr>
                        <tr><td>メモリ (Limit)</td><td>${Math.ceil(results.broker.memory * 1.2)}</td><td>GB/pod</td></tr>
                        <tr><td>ストレージ (PVC)</td><td>${results.broker.storage}</td><td>GB/pod</td></tr>
                        <tr><td>クラスター総ストレージ</td><td>${results.broker.totalStorage}</td><td>GB</td></tr>
                    </table>
                    <div class="explanation">
                        <h5>📋 計算根拠</h5>
                        <ul>
                            <li><strong>Pod数の決定：</strong></li>
                            <li>　🔸 <strong>基本データ処理量計算：</strong></li>
                            <li>　　- 入力メッセージ処理量：${document.getElementById('messagesPerSecond').value}メッセージ/秒</li>
                            <li>　　- 平均メッセージサイズ：${document.getElementById('avgMessageSize').value}KB</li>
                            <li>　　- ${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリング調整：' + document.getElementById('messagesPerSecond').value + ' × 2 = ' + results.calculations.actualMessagesPerSecond + 'メッセージ/秒' : '単方向のため調整なし：' + results.calculations.actualMessagesPerSecond + 'メッセージ/秒'}</li>
                            <li>　　- 秒間データ量：${results.calculations.actualMessagesPerSecond} × ${document.getElementById('avgMessageSize').value}KB = ${Math.round(results.calculations.bytesPerSecond / 1024)}KB/s = ${Math.round(results.calculations.bytesPerSecond / 1024 / 1024)}MB/s</li>
                            <li>　🔸 <strong>パーティション数による制約：</strong></li>
                            <li>　　- 入力パーティション数：${document.getElementById('totalPartitions').value}</li>
                            <li>　　- ${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリング調整：' + document.getElementById('totalPartitions').value + ' × 2 = ' + results.calculations.actualTotalPartitions : '単方向のため調整なし：' + results.calculations.actualTotalPartitions}</li>
                            <li>　　- 総レプリカ数：${results.calculations.actualTotalPartitions} × ${document.getElementById('replicationFactor').value} = ${results.calculations.actualTotalPartitions * parseInt(document.getElementById('replicationFactor').value)}</li>
                            <li>　　- 必要ブローカー数：ceil(${results.calculations.actualTotalPartitions * parseInt(document.getElementById('replicationFactor').value)} ÷ 4000) = ${results.calculations.brokersByPartitions}台</li>
                            <li>　🔸 <strong>処理量による制約：</strong></li>
                            <li>　　- クラスター秒間処理量：${Math.round(results.calculations.bytesPerSecond / 1024 / 1024)}MB/s</li>
                            <li>　　- ブローカー実効スループット基準：213MB/s（3ノード・RF=3・2消費グループで640MB/s実用値の1/3）</li>
                            <li>　　- 安全率（80%使用）適用：213MB/s × 0.8 = 170MB/s</li>
                            <li>　　- 必要ブローカー数：ceil(${Math.round(results.calculations.bytesPerSecond / 1024 / 1024)}MB/s ÷ 170MB/s) = ${results.calculations.brokersByThroughput}台</li>
                            <li>　🔸 <strong>最終決定：</strong> max(最小3台, パーティション制約${results.calculations.brokersByPartitions}台, 処理量制約${results.calculations.brokersByThroughput}台) = ${results.broker.pods}台</li>
                            <li><strong>CPU設定：</strong></li>
                            <li>　- 基本CPU：8vCPU</li>
                            ${results.calculations.compressionEnabled ? '<li>　- 圧縮処理追加：+4vCPU</li>' : ''}
                            ${results.calculations.tlsEnabled ? '<li>　- TLS暗号化追加：+4vCPU</li>' : ''}
                            <li>　- 合計CPU：${results.broker.cpu}vCPU/pod</li>
                            <li><strong>メモリ設定：</strong></li>
                            <li>　- JVMヒープ：6GB（固定）</li>
                            <li>　- 30秒分データキャッシュ：${Math.round(results.calculations.bytesPerSecond / 1024 / 1024 / results.broker.pods * 30)}MB ≈ ${Math.round(results.broker.memory - 6)}GB</li>
                            <li>　- 合計メモリ：6GB + ${Math.round(results.broker.memory - 6)}GB = ${results.broker.memory}GB/pod</li>
                            <li><strong>ストレージ計算：</strong></li>
                            <li>　- 日次データ量：${Math.round(results.calculations.bytesPerSecond / 1024 / 1024)} MB/s × 86400秒 ÷ 1024 = ${Math.round(results.calculations.dailyDataGB)}GB/日</li>
                            <li>　- 保管期間考慮：${Math.round(results.calculations.dailyDataGB)}GB × ${document.getElementById('retentionDays').value}日 = ${Math.round(results.calculations.dailyDataGB * parseInt(document.getElementById('retentionDays').value))}GB</li>
                            <li>　- レプリケーション考慮：${Math.round(results.calculations.dailyDataGB * parseInt(document.getElementById('retentionDays').value))}GB × ${document.getElementById('replicationFactor').value} = ${Math.round(results.calculations.totalStorageGB)}GB</li>
                            <li>　- ブローカー分散：${Math.round(results.calculations.totalStorageGB)}GB ÷ ${results.broker.pods}台 = ${Math.round(results.calculations.totalStorageGB / results.broker.pods)}GB/pod</li>
                            <li>　- 安全率（85%使用）適用：${Math.round(results.calculations.totalStorageGB / results.broker.pods)}GB ÷ 0.85 = ${results.broker.storage}GB/pod</li>
                        </ul>
                    </div>
                </div>

                <div class="result-section">
                    <h4>🔄 MirrorMaker2</h4>
                    <table class="resource-table">
                        <tr><th>リソース</th><th>値</th><th>単位</th></tr>
                        <tr><td>インスタンス数</td><td>${results.mm2.instances}</td><td>個 (${results.calculations.mirroringType === 'bidirectional' ? '双方向' : '単方向'})</td></tr>
                        <tr><td>ワーカー数/インスタンス</td><td>${results.mm2.workersPerInstance}</td><td>pod/インスタンス</td></tr>
                        <tr><td>総Pod数</td><td>${results.mm2.totalWorkers}</td><td>個</td></tr>
                        <tr><td>tasks.max</td><td>${results.mm2.tasksMax}</td><td>個/インスタンス</td></tr>
                        <tr><td>CPU (Request)</td><td>${results.mm2.cpu}</td><td>vCPU/pod</td></tr>
                        <tr><td>CPU (Limit)</td><td>${Math.ceil(results.mm2.cpu * 1.5)}</td><td>vCPU/pod</td></tr>
                        <tr><td>メモリ (Request)</td><td>${results.mm2.memory}</td><td>GB/pod</td></tr>
                        <tr><td>メモリ (Limit)</td><td>${Math.ceil(results.mm2.memory * 1.5)}</td><td>GB/pod</td></tr>
                    </table>
                    <div class="explanation">
                        <h5>📋 計算根拠</h5>
                        <ul>
                            <li><strong>インスタンス数：</strong> ${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリングのため2つのMM2インスタンス（Blue→Green、Green→Blue）' : '単方向ミラーリングのため1つのMM2インスタンス'}</li>
                            <li><strong>ワーカー数：</strong> 高可用性のため各インスタンスに2つのワーカーを配置</li>
                            <li>　- インスタンス数：${results.mm2.instances}</li>
                            <li>　- ワーカー数/インスタンス：${results.mm2.workersPerInstance}</li>
                            <li>　- 総ワーカー数：${results.mm2.instances} × ${results.mm2.workersPerInstance} = ${results.mm2.totalWorkers}</li>
                            <li><strong>tasks.max計算：</strong></li>
                            <li>　- 複製対象パーティション数：${document.getElementById('totalPartitions').value}</li>
                            <li>　- 利用可能総CPU数：${results.broker.pods}ブローカー × ${results.broker.cpu}vCPU = ${results.broker.pods * results.broker.cpu}vCPU</li>
                            <li>　- tasks.max：min(${document.getElementById('totalPartitions').value}, ${results.broker.pods * results.broker.cpu}) = ${results.mm2.tasksMax}</li>
                            <li><strong>CPU設定：</strong></li>
                            <li>　- タスク数に基づく基本CPU：max(2, ceil(${results.mm2.tasksMax} ÷ ${results.mm2.workersPerInstance})) = ${Math.max(2, Math.ceil(results.mm2.tasksMax / results.mm2.workersPerInstance))}vCPU</li>
                            ${results.calculations.compressionEnabled ? '<li>　- 圧縮処理追加：+1vCPU</li>' : ''}
                            ${results.calculations.tlsEnabled ? '<li>　- TLS暗号化追加：+1vCPU</li>' : ''}
                            <li>　- 合計CPU：${results.mm2.cpu}vCPU/pod</li>
                            <li><strong>メモリ設定：</strong></li>
                            <li>　- CPU当たり配分：${results.mm2.cpu}vCPU × 0.5GB = ${Math.round(results.mm2.cpu * 0.5 * 10) / 10}GB</li>
                            <li>　- 最小保証：max(2GB, ${Math.round(results.mm2.cpu * 0.5 * 10) / 10}GB) = ${results.mm2.memory}GB/pod</li>
                        </ul>
                    </div>
                </div>

                <div class="result-section">
                    <h4>📊 計算サマリー</h4>
                    <table class="resource-table">
                        <tr><th>項目</th><th>入力値</th><th>調整後の値</th><th>説明</th></tr>
                        <tr><td>メッセージ処理量</td><td>${document.getElementById('messagesPerSecond').value}/秒</td><td>${results.calculations.actualMessagesPerSecond}/秒</td><td>${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリングのため2倍' : '単方向のため変更なし'}</td></tr>
                        <tr><td>総パーティション数</td><td>${document.getElementById('totalPartitions').value}</td><td>${results.calculations.actualTotalPartitions}</td><td>${results.calculations.mirroringType === 'bidirectional' ? '双方向ミラーリングのため2倍' : '単方向のため変更なし'}</td></tr>
                        <tr><td>コンシューマーグループ数</td><td>${document.getElementById('consumerGroups').value}</td><td>${results.calculations.actualConsumerGroups}</td><td>MM2を1つのコンシューマーグループとして追加</td></tr>
                        <tr><td>日次データ量</td><td>-</td><td>${Math.round(results.calculations.dailyDataGB)}GB</td><td>${Math.round(results.calculations.bytesPerSecond / 1024 / 1024)}MB/s × 86400秒 ÷ 1024 = ${Math.round(results.calculations.dailyDataGB)}GB</td></tr>
                        <tr><td>必要総ストレージ</td><td>-</td><td>${Math.round(results.calculations.totalStorageGB)}GB</td><td>${Math.round(results.calculations.dailyDataGB)}GB × ${document.getElementById('retentionDays').value}日 × RF${document.getElementById('replicationFactor').value} = ${Math.round(results.calculations.totalStorageGB)}GB</td></tr>
                    </table>
                </div>

                <div class="result-section">
                    <h4>⚠️ 重要な免責事項と運用上の注意事項</h4>
                    <div class="warning" style="background: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #dc3545;">
                        <strong>📢 この計算結果について</strong><br>
                        上記の計算結果は<strong>参考値・概算値</strong>であり、正確な最終回答ではありません。Kafka と MirrorMaker2 導入時に<strong>「どの程度のリソースが必要か」を把握するための目安</strong>としてご活用ください。実際のプロダクション環境では、これらの値を出発点として必ず負荷テストとモニタリングによる調整を行ってください。
                    </div>
                    <div class="explanation">
                        <ul>
                            <li><strong>ディスク使用率：</strong> 85%を超えないよう監視し、必要に応じてストレージを増設してください</li>
                            <li><strong>CPU使用率：</strong> 平常時60%以下を維持し、ピーク時の負荷に備えてください</li>
                            <li><strong>メモリ使用率：</strong> JVMヒープは総メモリの25%以下に抑え、残りをページキャッシュとして活用してください</li>
                            <li><strong>ネットワーク：</strong> 各ブローカーが${Math.round(results.calculations.bytesPerSecond / results.broker.pods / 1024 / 1024)}MB/s程度の処理を行うため、十分なネットワーク帯域を確保してください</li>
                            <li><strong>負荷テスト：</strong> 本計算結果を出発点として実際の負荷テストを行い、環境に応じて必ず調整してください</li>
                            <li><strong>継続的モニタリング：</strong> 実際の使用量を継続的に監視し、必要に応じてリソースを調整してください</li>
                        </ul>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }
    </script>
</body>
</html>